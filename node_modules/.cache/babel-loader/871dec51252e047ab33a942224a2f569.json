{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.deleteFile = deleteFile, exports.writeMetadataToDb = writeMetadataToDb, exports.uploadFileWithProgress = uploadFileWithProgress;\n\nvar _isUndefined2 = _interopRequireDefault(require(\"lodash/isUndefined\")),\n    _omitBy2 = _interopRequireDefault(require(\"lodash/omitBy\")),\n    _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n    FILE_UPLOAD_PROGRESS = _constants.actionTypes.FILE_UPLOAD_PROGRESS;\n\nfunction deleteFile(firebase, _ref) {\n  var path = _ref.path,\n      dbPath = _ref.dbPath;\n  return firebase.storage().ref(path).delete().then(function () {\n    if (!dbPath || !firebase.database && !firebase.firestore) return {\n      path: path\n    };\n    return function metaDeletePromise() {\n      return firebase._.config.useFirestoreForStorageMeta ? firebase.firestore().doc(dbPath).delete() : firebase.database().ref(dbPath).remove();\n    }().then(function () {\n      return {\n        path: path,\n        dbPath: dbPath\n      };\n    });\n  });\n}\n\nfunction createUploadMetaResponseHandler(_ref2) {\n  var fileData = _ref2.fileData,\n      firebase = _ref2.firebase,\n      uploadTaskSnapshot = _ref2.uploadTaskSnapshot,\n      downloadURL = _ref2.downloadURL;\n  return function (metaDataSnapshot) {\n    var useFirestoreForStorageMeta = firebase._.config.useFirestoreForStorageMeta,\n        result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot: metaDataSnapshot,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta ? firebase.firestore.FieldValue.serverTimestamp() : firebase.database.ServerValue.TIMESTAMP\n    };\n    return metaDataSnapshot.id && (result.id = metaDataSnapshot.id), downloadURL && (result.downloadURL = downloadURL), result;\n  };\n}\n\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  return uploadTaskSnapshot.ref && \"function\" == typeof uploadTaskSnapshot.ref.getDownloadURL ? uploadTaskSnapshot.ref.getDownloadURL() : Promise.resolve(uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]);\n}\n\nfunction writeMetadataToDb(_ref3) {\n  var firebase = _ref3.firebase,\n      uploadTaskSnapshot = _ref3.uploadTaskSnapshot,\n      dbPath = _ref3.dbPath,\n      options = _ref3.options,\n      _firebase$_$config = firebase._.config,\n      fileMetadataFactory = _firebase$_$config.fileMetadataFactory,\n      useFirestoreForStorageMeta = _firebase$_$config.useFirestoreForStorageMeta,\n      metadataFactory = options.metadataFactory,\n      metaFactoryFunction = metadataFactory || fileMetadataFactory;\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(function (downloadURL) {\n    var fileData = \"function\" == typeof metaFactoryFunction ? metaFactoryFunction(uploadTaskSnapshot, firebase, uploadTaskSnapshot.metadata, downloadURL) : (0, _omitBy2.default)(uploadTaskSnapshot.metadata, _isUndefined2.default),\n        resultFromSnap = createUploadMetaResponseHandler({\n      fileData: fileData,\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      downloadURL: downloadURL\n    });\n    return function metaSetPromise(fileData) {\n      if (useFirestoreForStorageMeta) return firebase.firestore().collection(dbPath).add(fileData);\n      var newMetaRef = firebase.database().ref(dbPath).push();\n      return newMetaRef.set(fileData).then(function () {\n        return newMetaRef;\n      });\n    }(fileData).then(resultFromSnap);\n  });\n}\n\nfunction uploadFileWithProgress(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n      file = _ref4.file,\n      filename = _ref4.filename,\n      meta = _ref4.meta,\n      fileMetadata = _ref4.fileMetadata,\n      uploadEvent = firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata),\n      unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: function next(snapshot) {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta: meta,\n        payload: {\n          snapshot: snapshot,\n          percent: Math.floor(100 * (snapshot.bytesTransferred / snapshot.totalBytes))\n        }\n      });\n    },\n    error: function error(err) {\n      dispatch({\n        type: FILE_UPLOAD_ERROR,\n        meta: meta,\n        payload: err\n      }), unListen();\n    },\n    complete: function complete() {\n      unListen();\n    }\n  });\n  return uploadEvent;\n}","map":{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","FILE_UPLOAD_PROGRESS","actionTypes","path","dbPath","firebase","metaDeletePromise","fileData","uploadTaskSnapshot","downloadURL","useFirestoreForStorageMeta","result","snapshot","key","metaDataSnapshot","File","uploadTaskSnaphot","createdAt","id","Promise","options","fileMetadataFactory","metadataFactory","metaFactoryFunction","getDownloadURLFromUploadTaskSnapshot","resultFromSnap","createUploadMetaResponseHandler","metaSetPromise","newMetaRef","file","filename","meta","fileMetadata","uploadEvent","unListen","next","dispatch","type","payload","percent","Math","error","complete"],"mappings":"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","sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase\n              .firestore()\n              .doc(dbPath)\n              .delete() // file meta in Firestore\n          : firebase\n              .database()\n              .ref(dbPath)\n              .remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    downloadURL => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const metaSetPromise = fileData => {\n        if (useFirestoreForStorageMeta) {\n          return firebase // Write metadata to Firestore\n            .firestore()\n            .collection(dbPath)\n            .add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase\n          .database()\n          .ref(dbPath)\n          .push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then(res => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: snapshot => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            snapshot.bytesTransferred / snapshot.totalBytes * 100\n          )\n        }\n      })\n    },\n    error: err => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = firestoreConnect;\n\nvar _isEqual2 = _interopRequireDefault(require(\"lodash/isEqual\")),\n    _react = _interopRequireWildcard(require(\"react\")),\n    _propTypes = _interopRequireDefault(require(\"prop-types\")),\n    _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\")),\n    _utils = require(\"./utils\"),\n    _ReduxFirestoreContext = _interopRequireDefault(require(\"./ReduxFirestoreContext\")),\n    _ReactReduxFirebaseContext = _interopRequireDefault(require(\"./ReactReduxFirebaseContext\"));\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" != typeof WeakMap) return null;\n  var cache = new WeakMap();\n  return _getRequireWildcardCache = function () {\n    return cache;\n  }, cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) return obj;\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) return cache.get(obj);\n  var newObj = {};\n\n  if (null != obj) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];\n    }\n  }\n\n  return newObj.default = obj, cache && cache.set(obj, newObj), newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _extends() {\n  return _extends = Object.assign || function (target) {\n    for (var source, i = 1; i < arguments.length; i++) for (var key in source = arguments[i], source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);\n\n    return target;\n  }, _extends.apply(this, arguments);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  return call && (\"object\" === _typeof(call) || \"function\" == typeof call) ? call : _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction firestoreConnect() {\n  var queriesConfig = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : [];\n  return function (WrappedComponent) {\n    function FirestoreConnectWithContext(props) {\n      return _react.default.createElement(_ReactReduxFirebaseContext.default.Consumer, null, function (_internalFirebase) {\n        return _react.default.createElement(_ReduxFirestoreContext.default.Consumer, null, function (_internalFirestore) {\n          return _react.default.createElement(FirestoreConnectWrapped, _extends({}, props, {\n            dispatch: _internalFirebase.dispatch,\n            firestore: _internalFirestore,\n            firebase: _internalFirebase\n          }));\n        });\n      });\n    }\n\n    var FirestoreConnectWrapped = function (_Component) {\n      function FirestoreConnectWrapped() {\n        var _getPrototypeOf2, _this;\n\n        _classCallCheck(this, FirestoreConnectWrapped);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n        return _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FirestoreConnectWrapped)).call.apply(_getPrototypeOf2, [this].concat(args))), _defineProperty(_assertThisInitialized(_this), \"prevData\", null), _this;\n      }\n\n      return _inherits(FirestoreConnectWrapped, _Component), _createClass(FirestoreConnectWrapped, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          if (this.firestoreIsEnabled) {\n            var inputAsFunc = (0, _utils.createCallable)(queriesConfig);\n            this.prevData = inputAsFunc(this.props, this.props), this.props.firestore.setListeners(this.prevData);\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.firestoreIsEnabled && this.prevData && this.props.firestore.unsetListeners(this.prevData);\n        }\n      }, {\n        key: \"UNSAFE_componentWillReceiveProps\",\n        value: function UNSAFE_componentWillReceiveProps(np) {\n          var firestore = this.props.firestore,\n              inputAsFunc = (0, _utils.createCallable)(queriesConfig),\n              data = inputAsFunc(np, this.props);\n\n          if (this.firestoreIsEnabled && !(0, _isEqual2.default)(data, this.prevData)) {\n            var changes = (0, _utils.getChanges)(data, this.prevData);\n            this.prevData = data, firestore.unsetListeners(changes.removed), firestore.setListeners(changes.added);\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return _react.default.createElement(WrappedComponent, this.props);\n        }\n      }, {\n        key: \"firestoreIsEnabled\",\n        get: function get() {\n          return !!this.props.firestore;\n        }\n      }]), FirestoreConnectWrapped;\n    }(_react.Component);\n\n    return _defineProperty(FirestoreConnectWrapped, \"wrappedComponent\", WrappedComponent), _defineProperty(FirestoreConnectWrapped, \"displayName\", (0, _utils.wrapDisplayName)(WrappedComponent, \"FirestoreConnectWrapped\")), FirestoreConnectWrapped.propTypes = {\n      dispatch: _propTypes.default.func.isRequired,\n      firebase: _propTypes.default.object,\n      firestore: _propTypes.default.object\n    }, FirestoreConnectWithContext.displayName = (0, _utils.wrapDisplayName)(WrappedComponent, \"FirestoreConnect\"), FirestoreConnectWithContext.wrappedComponent = WrappedComponent, (0, _hoistNonReactStatics.default)(FirestoreConnectWithContext, WrappedComponent);\n  };\n}\n\nmodule.exports = exports.default;","map":{"version":3,"sources":["../src/firestoreConnect.js"],"names":["queriesConfig","FirestoreConnectWrapped","Component","WrappedComponent","firestore","inputAsFunc","data","changes","dispatch","PropTypes","firebase","_internalFirebase","FirestoreConnectWithContext"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { isEqual } from 'lodash'\nimport hoistStatics from 'hoist-non-react-statics'\nimport { createCallable, wrapDisplayName, getChanges } from './utils'\nimport ReduxFirestoreContext from './ReduxFirestoreContext'\nimport ReactReduxFirebaseContext from './ReactReduxFirebaseContext'\n\n/**\n * @augments React.Component\n * @description Higher Order Component that automatically listens/unListens\n * to provided Cloud Firestore paths using React's Lifecycle hooks. Make sure you\n * have required/imported Cloud Firestore, including it's reducer, before\n * attempting to use. **Note** Populate is not yet supported.\n * @param {Array|Function} queriesConfig - Array of objects or strings for paths to sync\n * from Firebase. Can also be a function that returns the array. The function\n * is passed the current props and the firebase object.\n * @returns {Function} - Function which accepts a component to wrap and returns the\n * wrapped component\n * @see https://react-redux-firebase.com/docs/api/firestoreConnect.html\n * @example <caption>Basic</caption>\n * // props.firebase set on App component as firebase object with helpers\n * import { firestoreConnect } from 'react-redux-firebase'\n * export default firestoreConnect()(SomeComponent)\n * @example <caption>Basic</caption>\n * import { connect } from 'react-redux'\n * import { firestoreConnect } from 'react-redux-firebase'\n *\n * // pass todos list from redux as props.todosList\n * export default compose(\n *   firestoreConnect(() => ['todos']), // sync todos collection from Firestore into redux\n *   connect((state) => ({\n *     todosList: state.firestore.data.todos\n *   })\n * )(SomeComponent)\n */\nexport default function firestoreConnect(queriesConfig = []) {\n  return WrappedComponent => {\n    class FirestoreConnectWrapped extends Component {\n      static wrappedComponent = WrappedComponent\n      static displayName = wrapDisplayName(\n        WrappedComponent,\n        'FirestoreConnectWrapped'\n      )\n\n      prevData = null\n\n      get firestoreIsEnabled() {\n        return !!this.props.firestore\n      }\n\n      componentDidMount() {\n        if (this.firestoreIsEnabled) {\n          // Listener configs as object (handling function being passed)\n          const inputAsFunc = createCallable(queriesConfig)\n          this.prevData = inputAsFunc(this.props, this.props)\n          // Attach listeners based on listener config\n          this.props.firestore.setListeners(this.prevData)\n        }\n      }\n\n      componentWillUnmount() {\n        if (this.firestoreIsEnabled && this.prevData) {\n          this.props.firestore.unsetListeners(this.prevData)\n        }\n      }\n\n      /* eslint-disable camelcase */\n      UNSAFE_componentWillReceiveProps(np) {\n        /* eslint-enable camelcase */\n        const { firestore } = this.props\n        const inputAsFunc = createCallable(queriesConfig)\n        const data = inputAsFunc(np, this.props)\n\n        // Check for changes in the listener configs\n        if (this.firestoreIsEnabled && !isEqual(data, this.prevData)) {\n          const changes = getChanges(data, this.prevData)\n\n          this.prevData = data\n\n          // Remove listeners for inactive subscriptions\n          firestore.unsetListeners(changes.removed)\n\n          // Add listeners for new subscriptions\n          firestore.setListeners(changes.added)\n        }\n      }\n\n      render() {\n        return <WrappedComponent {...this.props} />\n      }\n    }\n\n    FirestoreConnectWrapped.propTypes = {\n      dispatch: PropTypes.func.isRequired,\n      firebase: PropTypes.object,\n      firestore: PropTypes.object\n    }\n\n    /**\n     * Render component wrapped in context\n     * @param {object} props - Component props\n     * @returns {React.Component} Component wrapped in context\n     */\n    function FirestoreConnectWithContext(props) {\n      return (\n        <ReactReduxFirebaseContext.Consumer>\n          {_internalFirebase => (\n            <ReduxFirestoreContext.Consumer>\n              {_internalFirestore => (\n                <FirestoreConnectWrapped\n                  {...props}\n                  dispatch={_internalFirebase.dispatch}\n                  firestore={_internalFirestore}\n                  firebase={_internalFirebase}\n                />\n              )}\n            </ReduxFirestoreContext.Consumer>\n          )}\n        </ReactReduxFirebaseContext.Consumer>\n      )\n    }\n\n    FirestoreConnectWithContext.displayName = wrapDisplayName(\n      WrappedComponent,\n      'FirestoreConnect'\n    )\n\n    FirestoreConnectWithContext.wrappedComponent = WrappedComponent\n\n    return hoistStatics(FirestoreConnectWithContext, WrappedComponent)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
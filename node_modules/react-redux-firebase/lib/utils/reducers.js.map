{"version":3,"sources":["../../src/utils/reducers.js"],"names":["pathToArr","path","split","filter","p","getSlashStrPath","join","getDotStrPath","combineReducers","reducers","state","action","Object","keys","reduce","nextState","key","preserveValuesFromState","preserveSetting","Array","isArray","Error","recursiveUnset","obj","isRecursiveCall","objectWithRemovedKey","newPath","match","replace"],"mappings":"u/CASO,QAASA,CAAAA,SAAT,CAAmBC,IAAnB,CAAyB,CAC9B,MAAOA,CAAAA,IAAI,CAAGA,IAAI,CAACC,KAAL,CAAW,IAAX,EAAiBC,MAAjB,CAAwB,SAAAC,CAAC,QAAI,CAAC,CAACA,CAAN,CAAzB,CAAH,CAAuC,EACnD,CAQM,QAASC,CAAAA,eAAT,CAAyBJ,IAAzB,CAA+B,CACpC,MAAOD,CAAAA,SAAS,CAACC,IAAD,CAAT,CAAgBK,IAAhB,CAAqB,GAArB,CACR,CAQM,QAASC,CAAAA,aAAT,CAAuBN,IAAvB,CAA6B,CAClC,MAAOD,CAAAA,SAAS,CAACC,IAAD,CAAT,CAAgBK,IAAhB,CAAqB,GAArB,CACR,CAYM,QAASE,CAAAA,eAAT,CAAyBC,QAAzB,CAAmC,CACxC,MAAO,WAAwB,IAAvBC,CAAAA,KAAuB,wDAAf,EAAe,CAAXC,MAAW,wCAC7B,MAAOC,CAAAA,MAAM,CAACC,IAAP,CAAYJ,QAAZ,EAAsBK,MAAtB,CAA6B,SAACC,SAAD,CAAYC,GAAZ,CAAoB,CAMtD,MALAD,CAAAA,SAAS,CAACC,GAAD,CAAT,CAAiBP,QAAQ,CAACO,GAAD,CAAR,CAEfN,KAAK,CAACM,GAAD,CAFU,CAGfL,MAHe,CAKjB,CAAOI,SACR,CAPM,CAOJ,EAPI,CAQR,CACF,CAUM,QAASE,CAAAA,uBAAT,CAAiCP,KAAjC,CAAwCQ,eAAxC,CAAyDH,SAAzD,CAAoE,CAEzE,GAA+B,UAA3B,QAAOG,CAAAA,eAAX,CACE,MAAOA,CAAAA,eAAe,CAACR,KAAD,CAAQK,SAAR,CAAtB,CAIF,GAAI,KAAAG,eAAJ,CACE,MAAOH,CAAAA,SAAS,kBAAQL,KAAR,IAAkBK,SAAlB,EAAgCL,KAAhD,CAGF,GAAIS,KAAK,CAACC,OAAN,CAAcF,eAAd,CAAJ,CACE,MAAO,mBAAKR,KAAL,CAAYQ,eAAZ,CAAP,CAGF,KAAM,IAAIG,CAAAA,KAAJ,CACJ,8DADI,CAGP,CAYM,QAASC,CAAAA,cAAT,CAAwBrB,IAAxB,CAA8BsB,GAA9B,CAA4D,IAAzBC,CAAAA,eAAyB,6DACjE,GAAI,CAACvB,IAAL,CACE,MAAOsB,CAAAA,GAAP,CAGF,GAA2B,CAAvB,oBAAK,kBAAIA,GAAJ,CAAStB,IAAT,CAAL,GAA4BuB,eAAhC,CACE,MAAOD,CAAAA,GAAP,CAN+D,GAU3DE,CAAAA,oBAAoB,CAAG,oBAAMxB,IAAN,CAAYsB,GAAZ,CAVoC,CAW3DG,OAAO,CAAGzB,IAAI,CAAC0B,KAAL,CAAW,IAAX,EAAmB1B,IAAI,CAAC2B,OAAL,CAAa,UAAb,CAAyB,EAAzB,CAAnB,CAAkD,EAXD,CAYjE,MAAON,CAAAA,cAAc,CAACI,OAAD,CAAUD,oBAAV,IACtB","sourcesContent":["import { get, size, pick } from 'lodash'\nimport { unset } from 'lodash/fp'\n\n/**\n * Create a path array from path string\n * @param {string} path - Path seperated with slashes\n * @returns {Array} Path as Array\n * @private\n */\nexport function pathToArr(path) {\n  return path ? path.split(/\\//).filter(p => !!p) : []\n}\n\n/**\n * Trim leading slash from path for use with state\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with slashes\n * @private\n */\nexport function getSlashStrPath(path) {\n  return pathToArr(path).join('/')\n}\n\n/**\n * Convert path with slashes to dot seperated path (for use with lodash get/set)\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with dots\n * @private\n */\nexport function getDotStrPath(path) {\n  return pathToArr(path).join('.')\n}\n\n/**\n * Combine reducers utility (abreveated version of redux's combineReducer).\n * Turns an object whose values are different reducer functions, into a single\n * reducer function.\n * @param {object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one.\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n * @private\n */\nexport function combineReducers(reducers) {\n  return (state = {}, action) => {\n    return Object.keys(reducers).reduce((nextState, key) => {\n      nextState[key] = reducers[key](\n        // eslint-disable-line no-param-reassign\n        state[key],\n        action\n      )\n      return nextState\n    }, {})\n  }\n}\n\n/**\n * Preserve values from redux state change\n * @param {object} state - Redux state\n * @param {Function|boolean|Array} preserveSetting - Setting for which values to preserve\n * from redux state\n * @param {object} nextState - Next redux state\n * @returns {object} State with values preserved\n */\nexport function preserveValuesFromState(state, preserveSetting, nextState) {\n  // Return result of function if preserve is a function\n  if (typeof preserveSetting === 'function') {\n    return preserveSetting(state, nextState)\n  }\n\n  // Return original state if preserve is true\n  if (preserveSetting === true) {\n    return nextState ? { ...state, ...nextState } : state\n  }\n\n  if (Array.isArray(preserveSetting)) {\n    return pick(state, preserveSetting) // pick returns a new object\n  }\n\n  throw new Error(\n    'Invalid preserve parameter. It must be an Object or an Array'\n  )\n}\n\n/**\n * Recursively unset a property starting at the deep path, and unsetting the parent\n * property if there are no other enumerable properties at that level.\n * @param {string} path - Deep dot path of the property to unset\n * @param {object} obj - Object from which path should be recursivley unset\n * @param {boolean} [isRecursiveCall=false] - Used internally to ensure that\n * the object size check is only performed after one iteration.\n * @returns {object} The object with the property deeply unset\n * @private\n */\nexport function recursiveUnset(path, obj, isRecursiveCall = false) {\n  if (!path) {\n    return obj\n  }\n\n  if (size(get(obj, path)) > 0 && isRecursiveCall) {\n    return obj\n  }\n  // The object does not have any other properties at this level.  Remove the\n  // property.\n  const objectWithRemovedKey = unset(path, obj)\n  const newPath = path.match(/\\./) ? path.replace(/\\.[^.]*$/, '') : ''\n  return recursiveUnset(newPath, objectWithRemovedKey, true)\n}\n"],"file":"reducers.js"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.wrapInDispatch = wrapInDispatch, exports.mapWithFirebaseAndDispatch = mapWithFirebaseAndDispatch;\n\nvar _mapValues2 = _interopRequireDefault(require(\"lodash/mapValues\")),\n    _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr)) {\n    var _arr = [],\n        _n = !0,\n        _d = !1,\n        _e = void 0;\n\n    try {\n      for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        _n || null == _i[\"return\"] || _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction wrapInDispatch(dispatch, _ref) {\n  var ref = _ref.ref,\n      meta = _ref.meta,\n      method = _ref.method,\n      _ref$args = _ref.args,\n      args = void 0 === _ref$args ? [] : _ref$args,\n      types = _ref.types,\n      _types = _slicedToArray(types, 3),\n      requestingType = _types[0],\n      successType = _types[1],\n      errorType = _types[2];\n\n  return dispatch({\n    type: (0, _isObject2.default)(requestingType) ? requestingType.type : requestingType,\n    meta: meta,\n    payload: (0, _isObject2.default)(requestingType) ? requestingType.payload : {\n      args: args\n    }\n  }), method.apply(void 0, _toConsumableArray(args)).then(function (payload) {\n    return dispatch({\n      type: (0, _isObject2.default)(successType) ? successType.type : successType,\n      meta: meta,\n      payload: (0, _isObject2.default)(successType) ? successType.payload : payload\n    }), payload;\n  }).catch(function (err) {\n    return dispatch({\n      type: errorType,\n      meta: meta,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\n\nfunction createWithFirebaseAndDispatch(firebase, dispatch, dispatchFirst) {\n  return function (func) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n      return func.apply(firebase, dispatchFirst ? [dispatch, firebase].concat(args) : [firebase, dispatch].concat(args));\n    };\n  };\n}\n\nfunction mapWithFirebaseAndDispatch(firebase, dispatch, actions, reverseActions) {\n  var withFirebaseAndDispatch = createWithFirebaseAndDispatch(firebase, dispatch),\n      withDispatchAndFirebase = createWithFirebaseAndDispatch(firebase, dispatch, !0);\n  return _objectSpread({}, (0, _mapValues2.default)(actions, withFirebaseAndDispatch), {}, (0, _mapValues2.default)(reverseActions, withDispatchAndFirebase));\n}","map":{"version":3,"sources":["../../src/utils/actions.js"],"names":["ref","meta","method","args","types","requestingType","successType","errorType","dispatch","type","payload","Promise","func","dispatchFirst","withFirebaseAndDispatch","createWithFirebaseAndDispatch","withDispatchAndFirebase"],"mappings":"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","sourcesContent":["import { isObject, mapValues } from 'lodash'\n\n/**\n * Wrap method call in dispatched actions\n * @param {Function} dispatch - Action dispatch function\n * @param {object} opts - Options object\n * @param {Function} opts.method - Method to call\n * @param {Array} opts.args - Arguments to call method with\n * @param {Array} opts.types - Action types array ([BEFORE, SUCCESS, FAILURE])\n * @returns {Promise} Resolves after method is called and success action is dispatched\n * @private\n */\nexport function wrapInDispatch(\n  dispatch,\n  { ref, meta, method, args = [], types }\n) {\n  const [requestingType, successType, errorType] = types\n  dispatch({\n    type: isObject(requestingType) ? requestingType.type : requestingType,\n    meta,\n    payload: isObject(requestingType) ? requestingType.payload : { args }\n  })\n  return method(...args)\n    .then(payload => {\n      dispatch({\n        type: isObject(successType) ? successType.type : successType,\n        meta,\n        payload: isObject(successType) ? successType.payload : payload\n      })\n      return payload\n    })\n    .catch(err => {\n      dispatch({\n        type: errorType,\n        meta,\n        payload: err\n      })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Function that builds a factory that passes firebase and\n * dispatch as first two arguments.\n * @param {object} firebase - Internal firebase instance\n * @param {Function} dispatch - Redux's dispatch function\n * @param {boolean} dispatchFirst - Whether or not to have dispatch argument first\n * @returns {Function} A wrapper that accepts a function to wrap with firebase\n * and dispatch.\n */\nfunction createWithFirebaseAndDispatch(firebase, dispatch, dispatchFirst) {\n  return func => (...args) =>\n    func.apply(\n      firebase,\n      dispatchFirst\n        ? [dispatch, firebase, ...args]\n        : [firebase, dispatch, ...args]\n    )\n}\n\n/**\n * Map each action with Firebase and Dispatch. Includes aliasing of actions.\n * @param {object} firebase - Internal firebase instance\n * @param {Function} dispatch - Redux's dispatch function\n * @param {object} actions - Action functions to map with firebase and dispatch\n * @param {object} reverseActions - Action functions to map with dispatch and firebase (i.e. reverse arg order)\n * @returns {object} Actions mapped with firebase and dispatch\n */\nexport function mapWithFirebaseAndDispatch(\n  firebase,\n  dispatch,\n  actions,\n  reverseActions\n) {\n  const withFirebaseAndDispatch = createWithFirebaseAndDispatch(\n    firebase,\n    dispatch\n  )\n  const withDispatchAndFirebase = createWithFirebaseAndDispatch(\n    firebase,\n    dispatch,\n    true\n  )\n  return {\n    ...mapValues(actions, withFirebaseAndDispatch),\n    ...mapValues(reverseActions, withDispatchAndFirebase)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
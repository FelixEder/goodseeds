{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.getWatchPath = getWatchPath, exports.getQueryIdFromPath = getQueryIdFromPath, exports.setWatcher = setWatcher, exports.getWatcherCount = getWatcherCount, exports.unsetWatcher = unsetWatcher, exports.applyParamsToQuery = applyParamsToQuery, exports.orderedFromSnapshot = orderedFromSnapshot, exports.populateAndDispatch = populateAndDispatch;\n\nvar _forEach2 = _interopRequireDefault(require(\"lodash/forEach\")),\n    _isNaN2 = _interopRequireDefault(require(\"lodash/isNaN\")),\n    _constants = require(\"../constants\"),\n    _populate = require(\"./populate\"),\n    _index = require(\"./index\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction tryParseToNumber(value) {\n  var result = +value;\n  return (0, _isNaN2.default)(result) ? value : result;\n}\n\nfunction getWatchPath(event, path) {\n  if (!event || \"\" === event || !path) throw new Error(\"Event and path are required\");\n  return \"\".concat(event, \":\").concat(\"/\" === path.substring(0, 1) ? \"\" : \"/\").concat(path);\n}\n\nfunction getQueryIdFromPath(path, event) {\n  if (!(0, _index.isString)(path)) throw new Error(\"Query path must be a string\");\n  var origPath = path,\n      pathSplitted = path.split(\"#\");\n  path = pathSplitted[0];\n  var isQuery = 1 < pathSplitted.length,\n      queryParams = isQuery ? pathSplitted[1].split(\"&\") : [],\n      queryId = isQuery ? queryParams.map(function (param) {\n    var splittedParam = param.split(\"=\");\n    if (\"queryId\" === splittedParam[0]) return splittedParam[1];\n  }).filter(function (q) {\n    return q;\n  }) : void 0;\n  return queryId && 0 < queryId.length ? event ? \"\".concat(event, \":/\").concat(queryId) : queryId[0] : isQuery ? origPath : void 0;\n}\n\nfunction setWatcher(firebase, dispatch, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  return firebase._.watchers[id] ? firebase._.watchers[id]++ : firebase._.watchers[id] = 1, dispatch({\n    type: _constants.actionTypes.SET_LISTENER,\n    path: path,\n    payload: {\n      id: id\n    }\n  }), firebase._.watchers[id];\n}\n\nfunction getWatcherCount(firebase, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  return firebase._.watchers[id];\n}\n\nfunction unsetWatcher(firebase, dispatch, event, path, queryId) {\n  var id = queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path);\n  path = path.split(\"#\")[0];\n  var watchers = firebase._.watchers;\n  1 >= watchers[id] ? (delete watchers[id], \"first_child\" !== event && \"once\" !== event && firebase.database().ref().child(path).off(event)) : watchers[id] && watchers[id]--, dispatch({\n    type: _constants.actionTypes.UNSET_LISTENER,\n    path: path,\n    payload: {\n      id: id\n    }\n  });\n}\n\nfunction applyParamsToQuery(queryParams, query) {\n  var doNotParse = !1;\n  return queryParams && queryParams.forEach(function (param) {\n    switch (param = param.split(\"=\"), param[0]) {\n      case \"orderByValue\":\n        query = query.orderByValue(), doNotParse = !0;\n        break;\n\n      case \"orderByPriority\":\n        query = query.orderByPriority(), doNotParse = !0;\n        break;\n\n      case \"orderByKey\":\n        query = query.orderByKey(), doNotParse = !0;\n        break;\n\n      case \"orderByChild\":\n        query = query.orderByChild(param[1]);\n        break;\n\n      case \"limitToFirst\":\n        query = query.limitToFirst(parseInt(param[1], 10));\n        break;\n\n      case \"limitToLast\":\n        query = query.limitToLast(parseInt(param[1], 10));\n        break;\n\n      case \"notParsed\":\n        doNotParse = !0;\n        break;\n\n      case \"parsed\":\n        doNotParse = !1;\n        break;\n\n      case \"equalTo\":\n        var equalToParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        equalToParam = \"null\" === equalToParam ? null : equalToParam, equalToParam = \"false\" !== equalToParam && equalToParam, equalToParam = \"true\" === equalToParam || equalToParam, query = 3 === param.length ? query.equalTo(equalToParam, param[2]) : query.equalTo(equalToParam);\n        break;\n\n      case \"startAt\":\n        var startAtParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        startAtParam = \"null\" === startAtParam ? null : startAtParam, query = 3 === param.length ? query.startAt(startAtParam, param[2]) : query.startAt(startAtParam);\n        break;\n\n      case \"endAt\":\n        var endAtParam = doNotParse ? param[1] : tryParseToNumber(param[1]);\n        endAtParam = \"null\" === endAtParam ? null : endAtParam, query = 3 === param.length ? query.endAt(endAtParam, param[2]) : query.endAt(endAtParam);\n    }\n  }), query;\n}\n\nfunction orderedFromSnapshot(snap) {\n  if (snap.hasChildren && !snap.hasChildren()) return null;\n  var ordered = [];\n  return snap.forEach && snap.forEach(function (child) {\n    ordered.push({\n      key: child.key,\n      value: child.val()\n    });\n  }), ordered.length ? ordered : null;\n}\n\nfunction populateAndDispatch(firebase, dispatch, config) {\n  var data = config.data,\n      populates = config.populates,\n      snapshot = config.snapshot,\n      path = config.path,\n      storeAs = config.storeAs;\n  return (0, _populate.promisesForPopulate)(firebase, snapshot.key, data, populates).then(function (results) {\n    return (0, _forEach2.default)(results, function (result, path) {\n      dispatch({\n        type: _constants.actionTypes.MERGE,\n        path: path,\n        data: result\n      });\n    }), dispatch({\n      type: _constants.actionTypes.SET,\n      path: storeAs || path,\n      data: data,\n      ordered: orderedFromSnapshot(snapshot)\n    }), results;\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.ERROR,\n      payload: err\n    }), Promise.reject(err);\n  });\n}","map":{"version":3,"sources":["../../src/utils/query.js"],"names":["result","origPath","pathSplitted","path","isQuery","queryParams","queryId","splittedParam","param","event","id","getQueryIdFromPath","getWatchPath","firebase","dispatch","type","actionTypes","payload","watchers","doNotParse","query","parseInt","equalToParam","tryParseToNumber","startAtParam","endAtParam","snap","ordered","forEach","key","child","value","data","populates","snapshot","storeAs","config","orderedFromSnapshot","results","Promise"],"mappings":"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","sourcesContent":["import { actionTypes } from '../constants'\nimport { promisesForPopulate } from './populate'\nimport { isNaN, forEach } from 'lodash'\nimport { isString } from './index'\n\n/**\n * @private\n * Try to parse passed input to a number. If it is not a number return itself.\n * @param {string|number} value - Item to attempt to parse to a number\n * @returns {any} Number if parse to number was successful, otherwise,\n * original value\n */\nfunction tryParseToNumber(value) {\n  const result = Number(value)\n  if (isNaN(result)) {\n    return value\n  }\n  return result\n}\n\n/**\n * @private\n * Get path to watch provided event type and path.\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @returns {string} watchPath\n */\nexport function getWatchPath(event, path) {\n  if (!event || event === '' || !path) {\n    throw new Error('Event and path are required')\n  }\n  return `${event}:${path.substring(0, 1) === '/' ? '' : '/'}${path}`\n}\n\n/**\n * @private\n * Get query id from query path. queryId paramter is\n * later used to add/remove listeners from internal firebase instance.\n * @param {string} path - Path from which to get query id\n * @param {string} event - Type of query event\n * @returns {string} Query id\n */\nexport function getQueryIdFromPath(path, event) {\n  if (!isString(path)) {\n    throw new Error('Query path must be a string')\n  }\n  const origPath = path\n  let pathSplitted = path.split('#')\n  path = pathSplitted[0]\n\n  const isQuery = pathSplitted.length > 1\n  const queryParams = isQuery ? pathSplitted[1].split('&') : []\n  const queryId = isQuery\n    ? queryParams\n        .map(param => {\n          let splittedParam = param.split('=')\n          // Handle query id in path\n          if (splittedParam[0] === 'queryId') {\n            return splittedParam[1]\n          }\n        })\n        .filter(q => q)\n    : undefined\n  return queryId && queryId.length > 0\n    ? event ? `${event}:/${queryId}` : queryId[0]\n    : isQuery ? origPath : undefined\n}\n\n/**\n * @private\n * Update the number of watchers for a query\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux dispatch function\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n * @returns {number} watcherCount - count\n */\nexport function setWatcher(firebase, dispatch, event, path, queryId) {\n  const id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n\n  if (firebase._.watchers[id]) {\n    firebase._.watchers[id]++\n  } else {\n    firebase._.watchers[id] = 1\n  }\n\n  dispatch({ type: actionTypes.SET_LISTENER, path, payload: { id } })\n\n  return firebase._.watchers[id]\n}\n\n/**\n * @private\n * Get count of currently attached watchers\n * @param {object} firebase - Internal firebase object\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n * @returns {number} watcherCount\n */\nexport function getWatcherCount(firebase, event, path, queryId) {\n  const id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n  return firebase._.watchers[id]\n}\n\n/**\n * @private\n * Remove/Unset a watcher\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux's dispatch function\n * @param {string} event - Type of event to watch for\n * @param {string} path - Path to watch with watcher\n * @param {string} queryId - Id of query\n */\nexport function unsetWatcher(firebase, dispatch, event, path, queryId) {\n  let id =\n    queryId || getQueryIdFromPath(path, event) || getWatchPath(event, path)\n  path = path.split('#')[0]\n  const { watchers } = firebase._\n  if (watchers[id] <= 1) {\n    delete watchers[id]\n    if (event !== 'first_child' && event !== 'once') {\n      firebase\n        .database()\n        .ref()\n        .child(path)\n        .off(event)\n    }\n  } else if (watchers[id]) {\n    watchers[id]--\n  }\n\n  dispatch({ type: actionTypes.UNSET_LISTENER, path, payload: { id } })\n}\n\n/**\n * Modify query to include methods based on query parameters (such\n * as orderByChild).\n * @param {Array} queryParams - Array of query parameters to apply to query\n * @param {object} query - Query object on which to apply query parameters\n * @returns {firebase.database.Query} Query with query params applied\n */\nexport function applyParamsToQuery(queryParams, query) {\n  let doNotParse = false\n  if (queryParams) {\n    queryParams.forEach(param => {\n      param = param.split('=')\n      switch (param[0]) {\n        case 'orderByValue':\n          query = query.orderByValue()\n          doNotParse = true\n          break\n        case 'orderByPriority':\n          query = query.orderByPriority()\n          doNotParse = true\n          break\n        case 'orderByKey':\n          query = query.orderByKey()\n          doNotParse = true\n          break\n        case 'orderByChild':\n          query = query.orderByChild(param[1])\n          break\n        case 'limitToFirst':\n          // TODO: Handle number not being passed as param\n          query = query.limitToFirst(parseInt(param[1], 10))\n          break\n        case 'limitToLast':\n          // TODO: Handle number not being passed as param\n          query = query.limitToLast(parseInt(param[1], 10))\n          break\n        case 'notParsed':\n          // support disabling internal number parsing (number strings)\n          doNotParse = true\n          break\n        case 'parsed':\n          // support disabling internal number parsing (number strings)\n          doNotParse = false\n          break\n        case 'equalTo':\n          let equalToParam = !doNotParse ? tryParseToNumber(param[1]) : param[1]\n          equalToParam = equalToParam === 'null' ? null : equalToParam\n          equalToParam = equalToParam === 'false' ? false : equalToParam\n          equalToParam = equalToParam === 'true' ? true : equalToParam\n          query =\n            param.length === 3\n              ? query.equalTo(equalToParam, param[2])\n              : query.equalTo(equalToParam)\n          break\n        case 'startAt':\n          let startAtParam = !doNotParse ? tryParseToNumber(param[1]) : param[1]\n          startAtParam = startAtParam === 'null' ? null : startAtParam\n          query =\n            param.length === 3\n              ? query.startAt(startAtParam, param[2])\n              : query.startAt(startAtParam)\n          break\n        case 'endAt':\n          let endAtParam = !doNotParse ? tryParseToNumber(param[1]) : param[1]\n          endAtParam = endAtParam === 'null' ? null : endAtParam\n          query =\n            param.length === 3\n              ? query.endAt(endAtParam, param[2])\n              : query.endAt(endAtParam)\n          break\n      }\n    })\n  }\n\n  return query\n}\n\n/**\n * Get ordered array from snapshot\n * @param {firebase.database.DataSnapshot} snap - Data for which to create\n * an ordered array.\n * @returns {Array|null} Ordered list of children from snapshot or null\n */\nexport function orderedFromSnapshot(snap) {\n  if (snap.hasChildren && !snap.hasChildren()) {\n    return null\n  }\n  const ordered = []\n  if (snap.forEach) {\n    snap.forEach(child => {\n      ordered.push({ key: child.key, value: child.val() })\n    })\n  }\n  return ordered.length ? ordered : null\n}\n\n/**\n * Get data associated with populate settings, and dispatch\n *\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Redux's dispatch function\n * @param {object} config - Config object\n * @param {any} config.data - Original query data result\n * @param {Array} config.populates - List of populate settings\n * @param {string} config.path - Base query path\n * @param {string} config.storeAs - Location within redux in which to\n * query results will be stored (path is used as default if not provided).\n * @returns {Promise} Promise that resolves after data for populates has been\n * loaded and associated actions have been dispatched\n * @private\n */\nexport function populateAndDispatch(firebase, dispatch, config) {\n  const { data, populates, snapshot, path, storeAs } = config\n  // TODO: Allow setting of unpopulated data before starting population through config\n  return promisesForPopulate(firebase, snapshot.key, data, populates)\n    .then(results => {\n      // dispatch child sets first so isLoaded is only set to true for\n      // populatedDataToJS after all data is in redux (Issue #121)\n      // TODO: Allow config to toggle Combining into one SET action\n      // TODO: Set ordered for populate queries\n      forEach(results, (result, path) => {\n        dispatch({\n          type: actionTypes.MERGE,\n          path,\n          data: result\n        })\n      })\n      dispatch({\n        type: actionTypes.SET,\n        path: storeAs || path,\n        data,\n        ordered: orderedFromSnapshot(snapshot)\n      })\n      return results\n    })\n    .catch(err => {\n      dispatch({\n        type: actionTypes.ERROR,\n        payload: err\n      })\n      return Promise.reject(err)\n    })\n}\n"]},"metadata":{},"sourceType":"script"}
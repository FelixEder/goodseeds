{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.watchEvent = watchEvent, exports.unWatchEvent = unWatchEvent, exports.watchEvents = watchEvents, exports.unWatchEvents = unWatchEvents, exports.remove = remove;\n\nvar _constants = require(\"../constants\"),\n    _query = require(\"../utils/query\");\n\nfunction watchEvent(firebase, dispatch, options) {\n  if (!firebase.database || \"function\" != typeof firebase.database) throw new Error(\"Firebase database is required to create watchers\");\n  var type = options.type,\n      path = options.path,\n      populates = options.populates,\n      queryParams = options.queryParams,\n      queryId = options.queryId,\n      isQuery = options.isQuery,\n      storeAs = options.storeAs,\n      logErrors = firebase._.config.logErrors,\n      watchPath = storeAs ? \"\".concat(path, \"@\").concat(storeAs) : path,\n      id = queryId || (0, _query.getQueryIdFromPath)(path),\n      counter = (0, _query.getWatcherCount)(firebase, type, watchPath, id);\n  if (0 < counter && id && (0, _query.unsetWatcher)(firebase, dispatch, type, path, id), (0, _query.setWatcher)(firebase, dispatch, type, watchPath, id), \"first_child\" === type) return firebase.database().ref().child(path).orderByKey().limitToFirst(1).once(\"value\").then(function (snapshot) {\n    return null === snapshot.val() && dispatch({\n      type: _constants.actionTypes.NO_VALUE,\n      path: storeAs || path\n    }), snapshot;\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.ERROR,\n      path: storeAs || path,\n      payload: err\n    }), Promise.reject(err);\n  });\n  var query = firebase.database().ref().child(path);\n  return isQuery && (query = (0, _query.applyParamsToQuery)(queryParams, query)), dispatch({\n    type: _constants.actionTypes.START,\n    path: storeAs || path\n  }), \"once\" === type ? query.once(\"value\").then(function (snapshot) {\n    return null === snapshot.val() ? dispatch({\n      type: _constants.actionTypes.NO_VALUE,\n      path: storeAs || path\n    }) : populates ? (0, _query.populateAndDispatch)(firebase, dispatch, {\n      path: path,\n      storeAs: storeAs,\n      snapshot: snapshot,\n      data: snapshot.val(),\n      populates: populates\n    }) : dispatch({\n      type: _constants.actionTypes.SET,\n      path: storeAs || path,\n      data: snapshot.val(),\n      ordered: (0, _query.orderedFromSnapshot)(snapshot)\n    });\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      payload: err\n    }), Promise.reject(err);\n  }) : void query.on(type, function (snapshot) {\n    var data = \"child_removed\" === type ? void 0 : snapshot.val(),\n        resultPath = storeAs || \"value\" === type ? path : \"\".concat(path, \"/\").concat(snapshot.key);\n\n    if (!populates) {\n      var ordered = \"child_added\" === type ? [{\n        key: snapshot.key,\n        value: snapshot.val()\n      }] : (0, _query.orderedFromSnapshot)(snapshot);\n      return dispatch({\n        type: _constants.actionTypes.SET,\n        path: storeAs || resultPath,\n        data: data,\n        ordered: ordered\n      });\n    }\n\n    return (0, _query.populateAndDispatch)(firebase, dispatch, {\n      path: path,\n      storeAs: storeAs,\n      snapshot: snapshot,\n      data: snapshot.val(),\n      populates: populates\n    });\n  }, function (err) {\n    logErrors && console.log(\"Error retrieving data for path: \".concat(path, \", storeAs: \").concat(storeAs, \". Firebase:\"), err), dispatch({\n      type: _constants.actionTypes.ERROR,\n      storeAs: storeAs,\n      path: path,\n      payload: err\n    });\n  });\n}\n\nfunction unWatchEvent(firebase, dispatch, _ref) {\n  var type = _ref.type,\n      path = _ref.path,\n      storeAs = _ref.storeAs,\n      queryId = _ref.queryId,\n      watchPath = storeAs ? \"\".concat(path, \"@\").concat(storeAs) : path;\n  (0, _query.unsetWatcher)(firebase, dispatch, type, watchPath, queryId);\n}\n\nfunction watchEvents(firebase, dispatch, events) {\n  if (!Array.isArray(events)) throw new Error(\"Events config must be an Array\");\n  return events.map(function (event) {\n    return watchEvent(firebase, dispatch, event);\n  });\n}\n\nfunction unWatchEvents(firebase, dispatch, events) {\n  events.forEach(function (event) {\n    return unWatchEvent(firebase, dispatch, event);\n  });\n}\n\nfunction remove(firebase, dispatch, path) {\n  var options = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : {},\n      _options$dispatchActi = options.dispatchAction,\n      dispatchRemoveAction = firebase._.config.dispatchRemoveAction;\n  return firebase.database().ref(path).remove().then(function () {\n    return dispatchRemoveAction && (!(void 0 !== _options$dispatchActi) || _options$dispatchActi) && dispatch({\n      type: _constants.actionTypes.REMOVE,\n      path: path\n    }), path;\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.ERROR,\n      payload: err\n    }), Promise.reject(err);\n  });\n}","map":{"version":3,"sources":["../../src/actions/query.js"],"names":["firebase","type","path","populates","queryParams","queryId","isQuery","storeAs","options","logErrors","watchPath","id","counter","dispatch","actionTypes","snapshot","payload","Promise","query","data","ordered","resultPath","key","value","console","Array","events","watchEvent","unWatchEvent","dispatchRemoveAction"],"mappings":"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","sourcesContent":["import { actionTypes } from '../constants'\nimport {\n  orderedFromSnapshot,\n  populateAndDispatch,\n  applyParamsToQuery,\n  getWatcherCount,\n  setWatcher,\n  unsetWatcher,\n  getQueryIdFromPath\n} from '../utils/query'\n\n/**\n * Watch a path in Firebase Real Time Database\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} options - Event options object\n * @param {string} options.type - Type of event to watch for (defaults to value)\n * @param {string} options.path - Path to watch with watcher\n * @param {Array} options.queryParams - List of parameters for the query\n * @param {string} options.queryId - id of the query\n * @param {boolean} options.isQuery - id of the query\n * @param {string} options.storeAs - Location within redux to store value\n * @returns {Promise|void} Returns promise if query is a promise\n */\nexport function watchEvent(firebase, dispatch, options) {\n  if (!firebase.database || typeof firebase.database !== 'function') {\n    throw new Error('Firebase database is required to create watchers')\n  }\n  const {\n    type,\n    path,\n    populates,\n    queryParams,\n    queryId,\n    isQuery,\n    storeAs\n  } = options\n  const { config: { logErrors } } = firebase._\n\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  const id = queryId || getQueryIdFromPath(path)\n  const counter = getWatcherCount(firebase, type, watchPath, id)\n\n  if (counter > 0) {\n    if (id) {\n      unsetWatcher(firebase, dispatch, type, path, id)\n    }\n  }\n\n  setWatcher(firebase, dispatch, type, watchPath, id)\n\n  if (type === 'first_child') {\n    return firebase\n      .database()\n      .ref()\n      .child(path)\n      .orderByKey()\n      .limitToFirst(1)\n      .once('value')\n      .then(snapshot => {\n        if (snapshot.val() === null) {\n          dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        return snapshot\n      })\n      .catch(err => {\n        dispatch({\n          type: actionTypes.ERROR,\n          path: storeAs || path,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n\n  let query = firebase\n    .database()\n    .ref()\n    .child(path)\n\n  if (isQuery) {\n    query = applyParamsToQuery(queryParams, query)\n  }\n\n  dispatch({ type: actionTypes.START, path: storeAs || path })\n\n  // Handle once queries\n  if (type === 'once') {\n    return query\n      .once('value')\n      .then(snapshot => {\n        if (snapshot.val() === null) {\n          return dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        // dispatch normal event if no populates exist\n        if (!populates) {\n          // create an array for preserving order of children under ordered\n          return dispatch({\n            type: actionTypes.SET,\n            path: storeAs || path,\n            data: snapshot.val(),\n            ordered: orderedFromSnapshot(snapshot)\n          })\n        }\n        // populate and dispatch associated actions if populates exist\n        return populateAndDispatch(firebase, dispatch, {\n          path,\n          storeAs,\n          snapshot,\n          data: snapshot.val(),\n          populates\n        })\n      })\n      .catch(err => {\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n  // Handle all other queries\n\n  /* istanbul ignore next: is run by tests but doesn't show in coverage */\n  query.on(\n    type,\n    snapshot => {\n      let data = type === 'child_removed' ? undefined : snapshot.val()\n      const resultPath =\n        storeAs || type === 'value' ? path : `${path}/${snapshot.key}`\n\n      // Dispatch standard event if no populates exists\n      if (!populates) {\n        // create an array for preserving order of children under ordered\n        const ordered =\n          type === 'child_added'\n            ? [{ key: snapshot.key, value: snapshot.val() }]\n            : orderedFromSnapshot(snapshot)\n        return dispatch({\n          type: actionTypes.SET,\n          path: storeAs || resultPath,\n          data,\n          ordered\n        })\n      }\n      // populate and dispatch associated actions if populates exist\n      return populateAndDispatch(firebase, dispatch, {\n        path,\n        storeAs,\n        snapshot,\n        data: snapshot.val(),\n        populates\n      })\n    },\n    err => {\n      if (logErrors) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Error retrieving data for path: ${path}, storeAs: ${storeAs}. Firebase:`,\n          err\n        )\n      }\n      dispatch({\n        type: actionTypes.ERROR,\n        storeAs,\n        path,\n        payload: err\n      })\n    }\n  )\n}\n\n/**\n * Remove watcher from an event\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} config - Config object\n * @param {string} config.type - Type for which to remove the watcher (\n * value, once, first_child etc.)\n * @param {string} config.path - Path of watcher to remove\n * @param {string} config.storeAs - Path which to store results within in\n * redux store\n * @param {string} config.queryId - Id of the query (used for idendifying)\n * in internal watchers list\n */\nexport function unWatchEvent(\n  firebase,\n  dispatch,\n  { type, path, storeAs, queryId }\n) {\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  unsetWatcher(firebase, dispatch, type, watchPath, queryId)\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to add watchers\n * @returns {Array} ARray of watchEvent results\n */\nexport function watchEvents(firebase, dispatch, events) {\n  if (!Array.isArray(events)) {\n    throw new Error('Events config must be an Array')\n  }\n  return events.map(event => watchEvent(firebase, dispatch, event))\n}\n\n/**\n * Remove watchers from a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to remove watchers\n */\nexport function unWatchEvents(firebase, dispatch, events) {\n  events.forEach(event => unWatchEvent(firebase, dispatch, event))\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} path - Path of ref to be removed\n * @param {object} [options={}] - Configuration for removal\n * @param {boolean} [options.dispatchAction=true] - Whether or not to dispatch\n * REMOVE action\n * @returns {Promise} Resolves with path\n */\nexport function remove(firebase, dispatch, path, options = {}) {\n  const { dispatchAction = true } = options\n  const { dispatchRemoveAction } = firebase._.config\n  return firebase\n    .database()\n    .ref(path)\n    .remove()\n    .then(() => {\n      if (dispatchRemoveAction && dispatchAction) {\n        dispatch({ type: actionTypes.REMOVE, path })\n      }\n      return path\n    })\n    .catch(err => {\n      dispatch({ type: actionTypes.ERROR, payload: err })\n      return Promise.reject(err)\n    })\n}\n"]},"metadata":{},"sourceType":"script"}
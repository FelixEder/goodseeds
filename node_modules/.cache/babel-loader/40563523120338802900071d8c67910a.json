{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.pathToArr = pathToArr, exports.getSlashStrPath = getSlashStrPath, exports.getDotStrPath = getDotStrPath, exports.combineReducers = combineReducers, exports.preserveValuesFromState = preserveValuesFromState, exports.recursiveUnset = recursiveUnset;\n\nvar _unset2 = _interopRequireDefault(require(\"lodash/fp/unset\")),\n    _pick2 = _interopRequireDefault(require(\"lodash/pick\")),\n    _size2 = _interopRequireDefault(require(\"lodash/size\")),\n    _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction pathToArr(path) {\n  return path ? path.split(/\\//).filter(function (p) {\n    return !!p;\n  }) : [];\n}\n\nfunction getSlashStrPath(path) {\n  return pathToArr(path).join(\"/\");\n}\n\nfunction getDotStrPath(path) {\n  return pathToArr(path).join(\".\");\n}\n\nfunction combineReducers(reducers) {\n  return function () {\n    var state = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {},\n        action = 1 < arguments.length ? arguments[1] : void 0;\n    return Object.keys(reducers).reduce(function (nextState, key) {\n      return nextState[key] = reducers[key](state[key], action), nextState;\n    }, {});\n  };\n}\n\nfunction preserveValuesFromState(state, preserveSetting, nextState) {\n  if (\"function\" == typeof preserveSetting) return preserveSetting(state, nextState);\n  if (!0 === preserveSetting) return nextState ? _objectSpread({}, state, {}, nextState) : state;\n  if (Array.isArray(preserveSetting)) return (0, _pick2.default)(state, preserveSetting);\n  throw new Error(\"Invalid preserve parameter. It must be an Object or an Array\");\n}\n\nfunction recursiveUnset(path, obj) {\n  var isRecursiveCall = !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];\n  if (!path) return obj;\n  if (0 < (0, _size2.default)((0, _get2.default)(obj, path)) && isRecursiveCall) return obj;\n  var objectWithRemovedKey = (0, _unset2.default)(path, obj),\n      newPath = path.match(/\\./) ? path.replace(/\\.[^.]*$/, \"\") : \"\";\n  return recursiveUnset(newPath, objectWithRemovedKey, !0);\n}","map":{"version":3,"sources":["../../src/utils/reducers.js"],"names":["path","pathToArr","state","action","Object","nextState","reducers","preserveSetting","Array","isRecursiveCall","objectWithRemovedKey","newPath","recursiveUnset"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASO;;AAAA,SAAA,SAAA,CAAA,IAAA,EAAyB;AAC9B,SAAOA,IAAI,GAAGA,IAAI,CAAJA,KAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAwB,UAAA,CAAA,EAAC;AAAA,WAAI,CAAC,CAAL,CAAA;AAA5B,GAAGA,CAAH,GAAuC,EAAlD;AASK;;AAAA,SAAA,eAAA,CAAA,IAAA,EAA+B;AACpC,SAAOC,SAAS,CAATA,IAAS,CAATA,CAAAA,IAAAA,CAAAA,GAAAA,CAAP;AASK;;AAAA,SAAA,aAAA,CAAA,IAAA,EAA6B;AAClC,SAAOA,SAAS,CAATA,IAAS,CAATA,CAAAA,IAAAA,CAAAA,GAAAA,CAAP;AAaK;;AAAA,SAAA,eAAA,CAAA,QAAA,EAAmC;AACxC,SAAO,YAAwB;AAAvBC,QAAAA,KAAuB,GAAA,IAAA,SAAA,CAAA,MAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,KAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAf,EAARA;AAAAA,QAAYC,MAAW,GAAA,IAAA,SAAA,CAAA,MAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,KAAA,CAAvBD;AACN,WAAOE,MAAM,CAANA,IAAAA,CAAAA,QAAAA,EAAAA,MAAAA,CAA6B,UAAA,SAAA,EAAA,GAAA,EAAoB;AACtDC,aAAAA,SAAS,CAATA,GAAS,CAATA,GAAiBC,QAAQ,CAARA,GAAQ,CAARA,CAEfJ,KAAK,CAFUI,GAEV,CAFUA,EAAAA,MAAAA,CAAjBD,EAKOA,SALPA;AADKD,KAAAA,EAAAA,EAAAA,CAAP;AASH,GAVC;AAoBK;;AAAA,SAAA,uBAAA,CAAA,KAAA,EAAA,eAAA,EAAA,SAAA,EAAoE;AAEzE,MAAI,cAAA,OAAJ,eAAA,EACE,OAAOG,eAAe,CAAA,KAAA,EAAtB,SAAsB,CAAtB;AAIF,MAAI,CAAA,CAAA,KAAJ,eAAA,EACE,OAAOF,SAAS,GAAA,aAAA,CAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,SAAA,CAAA,GAAhB,KAAA;AAGF,MAAIG,KAAK,CAALA,OAAAA,CAAJ,eAAIA,CAAJ,EACE,OAAO,CAAA,GAAA,MAAA,CAAA,OAAA,EAAA,KAAA,EAAP,eAAO,CAAP;AAGF,QAAM,IAAA,KAAA,CAAA,8DAAA,CAAN;AAeK;;AAAA,SAAA,cAAA,CAAA,IAAA,EAAA,GAAA,EAA4D;AAAzBC,MAAAA,eAAyB,GAAA,CAAA,EAAA,IAAA,SAAA,CAAA,MAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,KAAA,CAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAzBA;AACxC,MAAI,CAAJ,IAAA,EACE,OAAA,GAAA;AAGF,MAAI,IAAA,CAAA,GAAA,MAAA,CAAA,OAAA,EAAK,CAAA,GAAA,KAAA,CAAA,OAAA,EAAA,GAAA,EAAL,IAAK,CAAL,CAAA,IAAJ,eAAA,EACE,OAAA,GAAA;AAN+D,MAU3DC,oBAAoB,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAA,IAAA,EAVoC,GAUpC,CAVoC;AAAA,MAW3DC,OAAO,GAAGX,IAAI,CAAJA,KAAAA,CAAAA,IAAAA,IAAmBA,IAAI,CAAJA,OAAAA,CAAAA,UAAAA,EAAnBA,EAAmBA,CAAnBA,GAXiD,EAAA;AAYjE,SAAOY,cAAc,CAAA,OAAA,EAAA,oBAAA,EAAA,CAAA,CAAA,CAArB;AACD","sourcesContent":["import { get, size, pick } from 'lodash'\nimport { unset } from 'lodash/fp'\n\n/**\n * Create a path array from path string\n * @param {string} path - Path seperated with slashes\n * @returns {Array} Path as Array\n * @private\n */\nexport function pathToArr(path) {\n  return path ? path.split(/\\//).filter(p => !!p) : []\n}\n\n/**\n * Trim leading slash from path for use with state\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with slashes\n * @private\n */\nexport function getSlashStrPath(path) {\n  return pathToArr(path).join('/')\n}\n\n/**\n * Convert path with slashes to dot seperated path (for use with lodash get/set)\n * @param {string} path - Path seperated with slashes\n * @returns {string} Path seperated with dots\n * @private\n */\nexport function getDotStrPath(path) {\n  return pathToArr(path).join('.')\n}\n\n/**\n * Combine reducers utility (abreveated version of redux's combineReducer).\n * Turns an object whose values are different reducer functions, into a single\n * reducer function.\n * @param {object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one.\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n * @private\n */\nexport function combineReducers(reducers) {\n  return (state = {}, action) => {\n    return Object.keys(reducers).reduce((nextState, key) => {\n      nextState[key] = reducers[key](\n        // eslint-disable-line no-param-reassign\n        state[key],\n        action\n      )\n      return nextState\n    }, {})\n  }\n}\n\n/**\n * Preserve values from redux state change\n * @param {object} state - Redux state\n * @param {Function|boolean|Array} preserveSetting - Setting for which values to preserve\n * from redux state\n * @param {object} nextState - Next redux state\n * @returns {object} State with values preserved\n */\nexport function preserveValuesFromState(state, preserveSetting, nextState) {\n  // Return result of function if preserve is a function\n  if (typeof preserveSetting === 'function') {\n    return preserveSetting(state, nextState)\n  }\n\n  // Return original state if preserve is true\n  if (preserveSetting === true) {\n    return nextState ? { ...state, ...nextState } : state\n  }\n\n  if (Array.isArray(preserveSetting)) {\n    return pick(state, preserveSetting) // pick returns a new object\n  }\n\n  throw new Error(\n    'Invalid preserve parameter. It must be an Object or an Array'\n  )\n}\n\n/**\n * Recursively unset a property starting at the deep path, and unsetting the parent\n * property if there are no other enumerable properties at that level.\n * @param {string} path - Deep dot path of the property to unset\n * @param {object} obj - Object from which path should be recursivley unset\n * @param {boolean} [isRecursiveCall=false] - Used internally to ensure that\n * the object size check is only performed after one iteration.\n * @returns {object} The object with the property deeply unset\n * @private\n */\nexport function recursiveUnset(path, obj, isRecursiveCall = false) {\n  if (!path) {\n    return obj\n  }\n\n  if (size(get(obj, path)) > 0 && isRecursiveCall) {\n    return obj\n  }\n  // The object does not have any other properties at this level.  Remove the\n  // property.\n  const objectWithRemovedKey = unset(path, obj)\n  const newPath = path.match(/\\./) ? path.replace(/\\.[^.]*$/, '') : ''\n  return recursiveUnset(newPath, objectWithRemovedKey, true)\n}\n"]},"metadata":{},"sourceType":"script"}
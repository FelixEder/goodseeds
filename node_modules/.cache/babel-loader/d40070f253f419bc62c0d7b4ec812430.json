{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.getVal = getVal, exports.isLoaded = isLoaded, exports.isEmpty = isEmpty, exports.fixPath = fixPath, exports.populate = populate;\n\nvar _some2 = _interopRequireDefault(require(\"lodash/some\")),\n    _defaultsDeep2 = _interopRequireDefault(require(\"lodash/defaultsDeep\")),\n    _reduce2 = _interopRequireDefault(require(\"lodash/reduce\")),\n    _mapValues2 = _interopRequireDefault(require(\"lodash/mapValues\")),\n    _map2 = _interopRequireDefault(require(\"lodash/map\")),\n    _has2 = _interopRequireDefault(require(\"lodash/has\")),\n    _get2 = _interopRequireDefault(require(\"lodash/get\")),\n    _set2 = _interopRequireDefault(require(\"lodash/set\")),\n    _size2 = _interopRequireDefault(require(\"lodash/size\")),\n    _constants = require(\"./constants\"),\n    _populate = require(\"./utils/populate\"),\n    _reducers = require(\"./utils/reducers\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction getVal(firebase, path, notSetValue) {\n  if (!firebase) return notSetValue;\n  var dotPath = (0, _reducers.getDotStrPath)(path),\n      valueAtPath = (0, _get2.default)(firebase, dotPath, notSetValue);\n  return valueAtPath;\n}\n\nfunction isLoaded() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n  return !(args && args.length) || args.every(function (arg) {\n    return arg !== void 0 && !1 !== (0, _get2.default)(arg, \"isLoaded\");\n  });\n}\n\nfunction isEmpty() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\n  return !(args && args.length) || args.some(function (arg) {\n    return !(arg && (0, _size2.default)(arg)) || !0 === arg.isEmpty;\n  });\n}\n\nfunction fixPath(path) {\n  return (\"/\" === path.substring(0, 1) ? \"\" : \"/\") + path;\n}\n\nfunction buildChildList(state, list, p) {\n  var mapFn = Array.isArray(list) ? _map2.default : _mapValues2.default;\n  return mapFn(list, function (val, key) {\n    var getKey = val;\n    (!0 === val || p.populateByKey) && (getKey = key);\n    var dotRoot = (0, _reducers.getDotStrPath)(p.root),\n        pathArr = [dotRoot, getKey];\n    p.childParam && pathArr.push(p.childParam);\n    var pathString = pathArr.join(\".\");\n    return (0, _get2.default)(state.data, pathString) ? p.keyProp ? _objectSpread(_defineProperty({}, p.keyProp, getKey), (0, _get2.default)(state.data, pathString)) : (0, _get2.default)(state.data, pathString) : !0 === val || p.populateByKey ? val : getKey;\n  });\n}\n\nfunction populateChild(state, child, p) {\n  var childVal = (0, _get2.default)(child, p.child);\n  if (!child || !childVal) return null;\n\n  if (\"string\" == typeof childVal || childVal instanceof String) {\n    var dotRoot = p.root.split(\"/\").filter(Boolean).join(\".\"),\n        pathArr = [dotRoot, childVal];\n    p.childParam && pathArr.push(p.childParam);\n    var pathString = pathArr.join(\".\"),\n        populateVal = (0, _get2.default)(state.data, pathString);\n    return populateVal ? (0, _set2.default)({}, p.childAlias || p.child, p.keyProp ? _objectSpread(_defineProperty({}, p.keyProp, childVal), populateVal) : populateVal) : child;\n  }\n\n  return (0, _set2.default)({}, p.childAlias || p.child, buildChildList(state, childVal, p));\n}\n\nfunction populate(state, path, populates, notSetValue) {\n  var splitPath = path.split(\"/\").filter(Boolean),\n      pathArr = -1 === _constants.topLevelPaths.indexOf(splitPath[0]) ? [\"data\"].concat(_toConsumableArray(splitPath)) : splitPath,\n      dotPath = pathArr.join(\".\"),\n      data = (0, _get2.default)(state, dotPath, notSetValue);\n  if (!state || data === notSetValue) return notSetValue;\n  if (null === data) return null;\n  var populatesForData = (0, _populate.getPopulateObjs)(\"function\" == typeof populates ? populates(pathArr.slice(-1)[0], data) : populates);\n\n  if (Array.isArray(data)) {\n    var someArrayItemHasKey = function (array) {\n      return function (key) {\n        return (0, _some2.default)(array, function (item) {\n          return (0, _has2.default)(item, key);\n        });\n      };\n    },\n        _dataHasPopulateChilds = (0, _some2.default)(populatesForData, function (populate) {\n      return someArrayItemHasKey(data)([\"value\", populate.child]);\n    });\n\n    return _dataHasPopulateChilds ? data.map(function (_ref) {\n      var key = _ref.key,\n          dataValue = _ref.value,\n          populatedValue = populatesForData.map(function (p) {\n        return populateChild(state, dataValue, p);\n      }).reduce(function (acc, v) {\n        return (0, _defaultsDeep2.default)(v, acc);\n      }, dataValue);\n      return {\n        key: key,\n        value: populatedValue\n      };\n    }) : data;\n  }\n\n  var dataHasPopulateChilds = (0, _some2.default)(populatesForData, function (p) {\n    return (0, _has2.default)(data, p.child);\n  });\n  return dataHasPopulateChilds ? populatesForData.map(function (p) {\n    return populateChild(state, data, p);\n  }).reduce(function (acc, v) {\n    return (0, _defaultsDeep2.default)(v, acc);\n  }, data) : -1 === pathArr.indexOf(\"profile\") ? (0, _mapValues2.default)(data, function (child, childKey) {\n    var key = \"ordered\" === pathArr[0] ? child.key : childKey,\n        populatesForDataItem = (0, _populate.getPopulateObjs)(\"function\" == typeof populates ? populates(key, child) : populates),\n        dataHasPopulateChilds = (0, _some2.default)(populatesForDataItem, function (p) {\n      return (0, _has2.default)(child, p.child);\n    });\n    return dataHasPopulateChilds ? (0, _reduce2.default)((0, _map2.default)(populatesForDataItem, function (p) {\n      return populateChild(state, child, p);\n    }), function (obj, v) {\n      return (0, _defaultsDeep2.default)(v, obj);\n    }, child) : child;\n  }) : data;\n}","map":{"version":3,"sources":["../src/helpers.js"],"names":["dotPath","valueAtPath","args","arg","path","mapFn","Array","getKey","p","dotRoot","pathArr","pathString","state","childVal","populateVal","child","buildChildList","splitPath","data","populatesForData","populates","someArrayItemHasKey","dataHasPopulateChilds","populate","key","value","dataValue","populatedValue","populateChild","populatesForDataItem"],"mappings":"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","sourcesContent":["import {\n  size,\n  set,\n  get,\n  has,\n  map,\n  mapValues,\n  reduce,\n  defaultsDeep,\n  some\n} from 'lodash'\nimport { topLevelPaths } from './constants'\nimport { getPopulateObjs } from './utils/populate'\nimport { getDotStrPath } from './utils/reducers'\n\n/**\n * **Deprecated** - This helper will be removed in future versions. Please\n * use object destructuring or utilities from other libraries such as\n * [lodash's get](https://lodash.com/docs/4.17.15#get).\n * Get a value from firebase using slash notation. This enables an easy\n * migration from v1's dataToJS/pathToJS/populatedDataToJS functions to v2 syntax\n * **NOTE:** Setting a default value will cause `isLoaded` to always return true\n * @param {object} firebase - Firebase instance (state.firebase)\n * @param {string} path - Path of parameter to load\n * @param {any} notSetValue - Value to return if value is not\n * found in redux. This will cause `isLoaded` to always return true (since\n * value is set from the start).\n * @returns {any} Data located at path within firebase.\n * @example <caption>Basic</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos/user1']),\n *   connect(({ firebase }) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     todos: getVal(firebase, 'data/todos/user1')\n *   }))\n * )\n * export default enhance(SomeComponent)\n * @example <caption>Base Paths</caption>\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * export default connect(({ firebase }) => ({\n *   // this.props.auth loaded from state.firebase.auth\n *   auth: getVal(firebase, 'auth'),\n *   profile: getVal(firebase, 'profile')\n * })(SomeComponent)\n * @example <caption>Default Value</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * const defaultValue = {\n *  1: {\n *    text: 'Example Todo'\n *  }\n * }\n *\n * const enhance = compose(\n *   firebaseConnect(['todos/user1']),\n *   connect(({ firebase }) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     todos: getVal(firebase, 'data/todos/user1', defaultValue)\n *   }))\n * )\n *\n * export default enhance(SomeComponent)\n */\nexport function getVal(firebase, path, notSetValue) {\n  if (!firebase) {\n    return notSetValue\n  }\n\n  const dotPath = getDotStrPath(path)\n  const valueAtPath = get(firebase, dotPath, notSetValue)\n\n  return valueAtPath\n}\n\n/**\n * Detect whether data from redux state is loaded yet or not\n * @param {...object} args - Items to check loaded status of. A comma separated\n * list is also acceptable.\n * @returns {boolean} Whether or not item is loaded\n * @example\n * import React from 'react'\n * import PropTypes from 'prop-types'\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import firebaseConnect from 'react-redux-firebase/lib/firebaseConnect'\n * import { isLoaded, isEmpty } from 'react-redux-firebase/lib/utils'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos']),\n *   connect(({ firebase: { data: { todos } } }) => ({\n *     todos // state.firebase.data.todos from redux passed as todos prop\n *   }))\n * )\n *\n * function Todos({ todos }) {\n *   // Message for if todos are loading\n *   if (!isLoaded(todos)) {\n *     return <span>Loading...</span>\n *   }\n *\n *   // Message if todos are empty\n *   if (isEmpty(todos)) {\n *     return <span>No Todos Found</span>\n *   }\n *\n *   return <div><pre>{JSON.stringify(todos, null, 2)}</pre></div>\n * }\n *\n * Todos.propTypes = {\n *   todos: PropTypes.object\n * }\n *\n * export default enhance(Todos)\n */\nexport function isLoaded(...args) {\n  return !args || !args.length\n    ? true\n    : args.every(arg => arg !== undefined && get(arg, 'isLoaded') !== false)\n}\n\n/**\n * Detect whether items are empty or not\n * @param {object} args - Item to check loaded status of. A comma seperated list\n * is also acceptable.\n * @returns {boolean} Whether or not item is empty\n * @example\n * import React from 'react'\n * import PropTypes from 'prop-types'\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, isEmpty, isLoaded } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos']),\n *   connect(({ firebase: { data: { todos } } }) => ({\n *     todos // state.firebase.data.todos from redux passed as todos prop\n *   }))\n * )\n *\n * function Todos({ todos }) {\n *   // Message for if todos are loading\n *   if (!isLoaded(todos)) {\n *     return <span>Loading...</span>\n *   }\n *\n *   // Message if todos are empty\n *   if (isEmpty(todos)) {\n *     return <span>No Todos Found</span>\n *   }\n *\n *   return <todos>{JSON.stringify(todos)}</todos>\n * }\n *\n * Todos.propTypes = {\n *   todos: PropTypes.object\n * }\n *\n * export default enhance(Todos)\n */\nexport function isEmpty(...args) {\n  return !args || !args.length\n    ? true\n    : args.some(arg => !(arg && size(arg)) || arg.isEmpty === true)\n}\n\n/**\n * @description Fix path by adding \"/\" to path if needed\n * @param {string} path - Path string to fix\n * @returns {string} - Fixed path\n * @private\n */\nexport function fixPath(path) {\n  return (path.substring(0, 1) === '/' ? '' : '/') + path\n}\n\n/**\n * @private\n * Build child list based on populate config\n * @param {object} state - Firebase state object\n * @param {object} list - Path of parameter to load\n * @param {object} p - Object with population settings\n * @returns {object} List of child objects\n */\nfunction buildChildList(state, list, p) {\n  const mapFn = Array.isArray(list) ? map : mapValues\n  return mapFn(list, (val, key) => {\n    let getKey = val\n    // Handle key: true lists\n    if (val === true || p.populateByKey) {\n      getKey = key\n    }\n    // Allow for aliasing populated data see #126 for more details\n    const dotRoot = getDotStrPath(p.root)\n    const pathArr = [dotRoot, getKey]\n\n    // Handle child param\n    if (p.childParam) {\n      pathArr.push(p.childParam)\n    }\n\n    const pathString = pathArr.join('.')\n\n    // Set to child under key if populate child exists\n    if (get(state.data, pathString)) {\n      return p.keyProp\n        ? { [p.keyProp]: getKey, ...get(state.data, pathString) }\n        : get(state.data, pathString)\n    }\n    // Populate child does not exist\n    return val === true || p.populateByKey ? val : getKey\n  })\n}\n\n/**\n * @private\n * Populate a child based on config. Handles list population\n * by making use of buildChildList.\n * @param {object} state - Firebase state object\n * @param {object} child - Path of parameter to load\n * @param {object} p - Object with population settings\n * @returns {object} Populated child object\n */\nfunction populateChild(state, child, p) {\n  // no matching child parameter\n  const childVal = get(child, p.child)\n  if (!child || !childVal) {\n    return null\n  }\n  // populate child is key\n  if (typeof childVal === 'string' || childVal instanceof String) {\n    // attach child paramter if it exists\n    const dotRoot = p.root\n      .split('/')\n      .filter(Boolean) // Drop falsey values (compact)\n      .join('.')\n    const pathArr = [dotRoot, childVal]\n\n    // Handle child param\n    if (p.childParam) {\n      pathArr.push(p.childParam)\n    }\n\n    const pathString = pathArr.join('.')\n\n    const populateVal = get(state.data, pathString)\n    if (populateVal) {\n      return set(\n        {},\n        p.childAlias || p.child,\n        p.keyProp ? { [p.keyProp]: childVal, ...populateVal } : populateVal\n      )\n    }\n    // matching child does not exist\n    return child\n  }\n  // populate child list\n  return set({}, p.childAlias || p.child, buildChildList(state, childVal, p))\n}\n\n/**\n * Populate with data from multiple locations of redux state.\n * @param {object} state - Firebase state object (state.firebase in redux store)\n * @param {string} path - Path of parameter to load\n * @param {Array} populates - Array of populate config objects\n * @param {object|string|boolean} notSetValue - Value to return if value is not found\n * @returns {object} Data located at path within Immutable Object\n * @example <caption>Basic</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect } from 'react-redux-firebase'\n * const populates = [{ child: 'owner', root: 'users' }]\n *\n * const enhance = compose(\n *   firebaseConnect([\n *     { path: 'todos', populates } // load \"todos\" and matching \"users\" to redux\n *   ]),\n *   connect((state) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     // each todo has child 'owner' populated from matching uid in 'users' root\n *     // for loading un-populated todos use state.firebase.data.todos\n *     todos: populate(state.firebase, 'todos', populates),\n *   }))\n * )\n *\n * export default enhance(SomeComponent)\n */\nexport function populate(state, path, populates, notSetValue) {\n  const splitPath = path.split('/').filter(Boolean) // Drop falsey values (compact)\n  // append 'data' prefix to path if it is not a top level path\n  const pathArr =\n    topLevelPaths.indexOf(splitPath[0]) === -1\n      ? ['data', ...splitPath]\n      : splitPath\n  const dotPath = pathArr.join('.')\n  // Gather data from top level if path is profile (handles populating profile)\n  const data = get(state, dotPath, notSetValue)\n\n  // Return notSetValue for undefined child\n  if (!state || data === notSetValue) {\n    return notSetValue\n  }\n  // Return null for null child\n  if (data === null) {\n    return null\n  }\n\n  // check for if data is single object or a list of objects\n  const populatesForData = getPopulateObjs(\n    typeof populates === 'function'\n      ? populates(pathArr.slice(-1)[0], data) // pass last slice in path\n      : populates\n  )\n\n  if (Array.isArray(data)) {\n    // When using a path in ordered, data will be an array instead of an object\n    // and data is located at the `value` prop\n    const someArrayItemHasKey = array => key =>\n      some(array, item => has(item, key))\n\n    // Check items within the list to see if value exists for some populate parameters\n    const dataHasPopulateChilds = some(populatesForData, populate =>\n      someArrayItemHasKey(data)(['value', populate.child])\n    )\n\n    // Populate if populate children exist\n    if (dataHasPopulateChilds) {\n      return data.map(({ key, value: dataValue }) => {\n        const populatedValue = populatesForData\n          .map(p => populateChild(state, dataValue, p))\n          .reduce((acc, v) => defaultsDeep(v, acc), dataValue)\n\n        return {\n          key,\n          value: populatedValue\n        }\n      })\n    }\n\n    // return unpopulated data if no populates have values\n    return data\n  }\n\n  // check each populate child parameter for existence\n  const dataHasPopulateChilds = some(populatesForData, p => has(data, p.child))\n\n  // Single object that contains at least one child parameter\n  if (dataHasPopulateChilds) {\n    return populatesForData\n      .map(p => populateChild(state, data, p))\n      .reduce((acc, v) => defaultsDeep(v, acc), data)\n  }\n\n  // Return for profile since it is a single object (following is for a list of objects)\n  // TODO: Improve this logic to allow for other paths containing profile\n  if (pathArr.indexOf('profile') !== -1) {\n    return data\n  }\n\n  // Data is a map of objects, each value has parameters to be populated\n  return mapValues(data, (child, childKey) => {\n    // use child's key if doing ordered populate\n    const key = pathArr[0] === 'ordered' ? child.key : childKey\n    // get populate settings on item level (passes child if populates is a function)\n    const populatesForDataItem = getPopulateObjs(\n      typeof populates === 'function' ? populates(key, child) : populates\n    )\n    // confirm at least one populate value exists on child\n    const dataHasPopulateChilds = some(populatesForDataItem, p =>\n      has(child, p.child)\n    )\n    // return unmodified child if no populate params exist on child\n    if (!dataHasPopulateChilds) {\n      return child\n    }\n    // combine data from all populates to one object starting with original data\n    return reduce(\n      map(populatesForDataItem, p => populateChild(state, child, p)),\n      (obj, v) => defaultsDeep(v, obj),\n      child\n    )\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
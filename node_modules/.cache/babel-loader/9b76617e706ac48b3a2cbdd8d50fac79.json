{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.uploadFile = uploadFile, exports.uploadFiles = uploadFiles, exports.deleteFile = deleteFile;\n\nvar _map2 = _interopRequireDefault(require(\"lodash/map\")),\n    _constants = require(\"../constants\"),\n    _actions = require(\"../utils/actions\"),\n    _storage = require(\"../utils/storage\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (null == source) return {};\n\n  var key,\n      i,\n      target = _objectWithoutPropertiesLoose(source, excluded);\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], !(0 <= excluded.indexOf(key)) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (null == source) return {};\n  var key,\n      i,\n      target = {},\n      sourceKeys = Object.keys(source);\n\n  for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], 0 <= excluded.indexOf(key) || (target[key] = source[key]);\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nvar FILE_UPLOAD_START = _constants.actionTypes.FILE_UPLOAD_START,\n    FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n    FILE_UPLOAD_COMPLETE = _constants.actionTypes.FILE_UPLOAD_COMPLETE,\n    FILE_DELETE_START = _constants.actionTypes.FILE_DELETE_START,\n    FILE_DELETE_ERROR = _constants.actionTypes.FILE_DELETE_ERROR,\n    FILE_DELETE_COMPLETE = _constants.actionTypes.FILE_DELETE_COMPLETE;\n\nfunction uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) throw new Error(\"Firebase storage is required to upload files\");\n\n  var _ref = config || {},\n      path = _ref.path,\n      file = _ref.file,\n      dbPath = _ref.dbPath,\n      _ref$options = _ref.options,\n      options = void 0 === _ref$options ? {\n    progress: !1\n  } : _ref$options,\n      fileMetadata = (options || {}).metadata,\n      logErrors = firebase._.config.logErrors,\n      nameFromOptions = \"function\" == typeof options.name ? options.name(file, firebase, config) : options.name,\n      filename = nameFromOptions || file.name,\n      meta = _objectSpread({}, config, {\n    filename: filename\n  });\n\n  dispatch({\n    type: FILE_UPLOAD_START,\n    payload: _objectSpread({}, config, {\n      filename: filename\n    })\n  });\n  return function uploadPromise() {\n    return options.progress ? (0, _storage.uploadFileWithProgress)(dispatch, firebase, {\n      path: path,\n      file: file,\n      filename: filename,\n      meta: meta,\n      fileMetadata: fileMetadata\n    }) : firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file, fileMetadata);\n  }().then(function (uploadTaskSnapshot) {\n    return dbPath && (firebase.database || firebase.firestore) ? (0, _storage.writeMetadataToDb)({\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      dbPath: dbPath,\n      options: options\n    }).then(function (payload) {\n      return dispatch({\n        type: FILE_UPLOAD_COMPLETE,\n        meta: _objectSpread({}, config, {\n          filename: filename\n        }),\n        payload: payload\n      }), payload;\n    }) : (dispatch({\n      type: FILE_UPLOAD_COMPLETE,\n      meta: _objectSpread({}, config, {\n        filename: filename\n      }),\n      payload: {\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        uploadTaskSnaphot: uploadTaskSnapshot\n      }\n    }), {\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot\n    });\n  }).catch(function (err) {\n    return logErrors && console.error && console.error(\"RRF: Error uploading file: \".concat(err.message || err), err), dispatch({\n      type: FILE_UPLOAD_ERROR,\n      path: path,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\n\nfunction uploadFiles(dispatch, firebase, _ref3) {\n  var files = _ref3.files,\n      other = _objectWithoutProperties(_ref3, [\"files\"]);\n\n  return Promise.all((0, _map2.default)(files, function (file) {\n    return uploadFile(dispatch, firebase, _objectSpread({\n      file: file\n    }, other));\n  }));\n}\n\nfunction deleteFile(dispatch, firebase, _ref4) {\n  var path = _ref4.path,\n      dbPath = _ref4.dbPath;\n  return (0, _actions.wrapInDispatch)(dispatch, {\n    method: _storage.deleteFile,\n    args: [firebase, {\n      path: path,\n      dbPath: dbPath\n    }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  });\n}","map":{"version":3,"sources":["../../src/actions/storage.js"],"names":["FILE_UPLOAD_START","FILE_UPLOAD_ERROR","FILE_UPLOAD_COMPLETE","FILE_DELETE_START","FILE_DELETE_ERROR","FILE_DELETE_COMPLETE","actionTypes","firebase","path","file","dbPath","options","progress","config","fileMetadata","logErrors","nameFromOptions","filename","meta","dispatch","type","payload","uploadPromise","uploadTaskSnapshot","uploadTaskSnaphot","console","err","Promise","files","other","uploadFile","method","deleteFileFromFb","args","types"],"mappings":"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","sourcesContent":["import { map } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { wrapInDispatch } from '../utils/actions'\nimport {\n  deleteFile as deleteFileFromFb,\n  writeMetadataToDb,\n  uploadFileWithProgress\n} from '../utils/storage'\n\nconst {\n  FILE_UPLOAD_START,\n  FILE_UPLOAD_ERROR,\n  FILE_UPLOAD_COMPLETE,\n  FILE_DELETE_START,\n  FILE_DELETE_ERROR,\n  FILE_DELETE_COMPLETE\n} = actionTypes\n\n/**\n * Upload file to Firebase Storage with option to store\n * file metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} config - Config object\n * @param {string} config.path - Location within Firebase Stroage at which to upload files.\n * @param {Blob} config.file - File Blob to be uploaded\n * @param {string} config.dbPath - Datbase path to write file meta data to\n * @param {object} config.options - Options\n * @param {string|Function} config.options.name - Name of file. If a function\n * is provided it recieves (fileObject, internalFirebase, config) as arguments.\n * @param {object} config.options.metdata - Metadata for file to be passed along\n * to storage.put calls\n * @returns {Promise} Resolves with meta object\n * @private\n */\nexport function uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) {\n    throw new Error('Firebase storage is required to upload files')\n  }\n  const { path, file, dbPath, options = { progress: false } } = config || {}\n  const { metadata: fileMetadata } = options || {}\n  const { logErrors } = firebase._.config\n\n  // File renaming through options (supporting string and function)\n  const nameFromOptions =\n    typeof options.name === 'function'\n      ? options.name(file, firebase, config)\n      : options.name\n  const filename = nameFromOptions || file.name\n\n  const meta = { ...config, filename }\n\n  // Dispatch start action\n  dispatch({ type: FILE_UPLOAD_START, payload: { ...config, filename } })\n\n  const uploadPromise = () =>\n    options.progress\n      ? uploadFileWithProgress(dispatch, firebase, {\n          path,\n          file,\n          filename,\n          meta,\n          fileMetadata\n        })\n      : firebase\n          .storage()\n          .ref(`${path}/${filename}`)\n          .put(file, fileMetadata)\n\n  return uploadPromise()\n    .then(uploadTaskSnapshot => {\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload: {\n            uploadTaskSnapshot,\n            uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n          }\n        })\n        return {\n          uploadTaskSnapshot,\n          uploadTaskSnaphot: uploadTaskSnapshot // Preserving legacy typo\n        }\n      }\n\n      // Write File metadata to either Real Time Database or Firestore (depending on config)\n      return writeMetadataToDb({\n        firebase,\n        uploadTaskSnapshot,\n        dbPath,\n        options\n      }).then(payload => {\n        dispatch({\n          type: FILE_UPLOAD_COMPLETE,\n          meta: { ...config, filename },\n          payload\n        })\n        return payload\n      })\n    })\n    .catch(err => {\n      if (logErrors) {\n        /* eslint-disable no-console */\n        console.error &&\n          console.error(`RRF: Error uploading file: ${err.message || err}`, err)\n        /* eslint-enable no-console */\n      }\n      dispatch({ type: FILE_UPLOAD_ERROR, path, payload: err })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Upload multiple files to Firebase Storage with option to store\n * file's metadata within Firebase Database\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {Array} opts.files - List of files to be uploaded\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with array of meta objects\n * @private\n */\nexport function uploadFiles(dispatch, firebase, { files, ...other }) {\n  return Promise.all(\n    map(files, file => uploadFile(dispatch, firebase, { file, ...other }))\n  )\n}\n\n/**\n * Delete File from Firebase Storage with option to remove meta\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - Options object\n * @param {string} opts.path - Storage path to write files to\n * @param {string} opts.dbPath - Datbase path to write file meta data to\n * @returns {Promise} Resolves with results of deleting a file from storage\n * @private\n */\nexport function deleteFile(dispatch, firebase, { path, dbPath }) {\n  return wrapInDispatch(dispatch, {\n    method: deleteFileFromFb,\n    args: [firebase, { path, dbPath }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
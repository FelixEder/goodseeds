{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.unWatchUserProfile = unWatchUserProfile, exports.handleProfileWatchResponse = handleProfileWatchResponse, exports.linkAndRetrieveDataWithCredential = linkAndRetrieveDataWithCredential, exports.linkWithPopup = linkWithPopup, exports.linkWithRedirect = linkWithRedirect, exports.signInWithPhoneNumber = signInWithPhoneNumber, exports.linkWithCredential = exports.reloadAuth = exports.updateEmail = exports.updateAuth = exports.updateProfile = exports.verifyPasswordResetCode = exports.confirmPasswordReset = exports.resetPassword = exports.createUser = exports.logout = exports.reauthenticate = exports.login = exports.init = exports.handleRedirectResult = exports.createUserProfile = exports.watchUserProfile = void 0;\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\")),\n    _omit2 = _interopRequireDefault(require(\"lodash/omit\")),\n    _forEach2 = _interopRequireDefault(require(\"lodash/forEach\")),\n    _constants = require(\"../constants\"),\n    _helpers = require(\"../helpers\"),\n    _utils = require(\"../utils\"),\n    _auth = require(\"../utils/auth\"),\n    _populate = require(\"../utils/populate\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction dispatchLoginError(dispatch, authError) {\n  var params = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {};\n  return dispatch(_objectSpread({\n    type: _constants.actionTypes.LOGIN_ERROR\n  }, params, {\n    authError: authError\n  }));\n}\n\nfunction unWatchUserProfile(firebase) {\n  var _firebase$_ = firebase._,\n      authUid = _firebase$_.authUid,\n      _firebase$_$config = _firebase$_.config,\n      userProfile = _firebase$_$config.userProfile,\n      useFirestoreForProfile = _firebase$_$config.useFirestoreForProfile;\n  firebase._.profileWatch && (useFirestoreForProfile && firebase.firestore ? firebase._.profileWatch() : firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).off(\"value\", firebase._.profileWatch), firebase._.profileWatch = null);\n}\n\nfunction getProfileFromSnap(snap) {\n  return snap && snap.val ? snap.val() : snap && snap.data && snap.exists ? snap.data() : null;\n}\n\nfunction handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token) {\n  var _firebase$_$config2 = firebase._.config,\n      profileParamsToPopulate = _firebase$_$config2.profileParamsToPopulate,\n      autoPopulateProfile = _firebase$_$config2.autoPopulateProfile,\n      useFirestoreForProfile = _firebase$_$config2.useFirestoreForProfile,\n      logErrors = _firebase$_$config2.logErrors,\n      profile = getProfileFromSnap(userProfileSnap);\n  profileParamsToPopulate && !useFirestoreForProfile && (Array.isArray(profileParamsToPopulate) || (0, _utils.isString)(profileParamsToPopulate)) ? (0, _populate.promisesForPopulate)(firebase, userProfileSnap.key, profile, profileParamsToPopulate).then(function (data) {\n    if ((0, _forEach2.default)(data, function (result, path) {\n      dispatch({\n        type: _constants.actionTypes.SET,\n        path: path,\n        data: result,\n        timestamp: Date.now(),\n        requesting: !1,\n        requested: !0\n      });\n    }), !autoPopulateProfile) dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: token ? _objectSpread({}, profile, {\n        token: token\n      }) : profile\n    });else {\n      var populates = (0, _populate.getPopulateObjs)(profileParamsToPopulate),\n          _profile = userProfileSnap.val();\n\n      dispatch({\n        type: _constants.actionTypes.SET_PROFILE,\n        profile: (0, _helpers.populate)({\n          profile: token ? _objectSpread({}, _profile, {\n            token: token\n          }) : _profile,\n          data: data\n        }, \"profile\", populates)\n      });\n    }\n  }).catch(function (err) {\n    logErrors && console.error(\"RRF: Error retrieving data for profile population. Firebase:\", err), dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: \"Error during profile population: \".concat(err.message)\n    }), dispatch({\n      type: _constants.actionTypes.SET_PROFILE,\n      profile: profile\n    });\n  }) : (useFirestoreForProfile && profileParamsToPopulate && console.warn(\"Profile population is not yet supported for Firestore\"), dispatch({\n    type: _constants.actionTypes.SET_PROFILE,\n    profile: token ? _objectSpread({}, profile, {\n      token: token\n    }) : profile\n  }));\n}\n\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  var _firebase$_$config3 = firebase._.config,\n      onProfileListenerError = _firebase$_$config3.onProfileListenerError,\n      logErrors = _firebase$_$config3.logErrors;\n  return function (err) {\n    if (logErrors && console.error(\"Error with profile listener: \".concat(err.message || \"\"), err), \"function\" == typeof onProfileListenerError) {\n      var factoryResult = onProfileListenerError(err, firebase);\n      if (\"function\" == typeof factoryResult.then) return factoryResult;\n    }\n\n    return Promise.reject(err);\n  };\n}\n\nvar watchUserProfile = function (dispatch, firebase) {\n  var _firebase$_2 = firebase._,\n      authUid = _firebase$_2.authUid,\n      _firebase$_2$config = _firebase$_2.config,\n      userProfile = _firebase$_2$config.userProfile,\n      useFirestoreForProfile = _firebase$_2$config.useFirestoreForProfile,\n      enableClaims = _firebase$_2$config.enableClaims;\n  if (unWatchUserProfile(firebase), userProfile) if (useFirestoreForProfile && firebase.firestore) firebase._.profileWatch = firebase.firestore().collection(userProfile).doc(authUid).onSnapshot(function (userProfileSnap) {\n    return enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else if (firebase.database) firebase._.profileWatch = firebase.database().ref().child(\"\".concat(userProfile, \"/\").concat(authUid)).on(\"value\", function (userProfileSnap) {\n    enableClaims ? firebase.auth().currentUser.getIdTokenResult(!0).then(function (token) {\n      return handleProfileWatchResponse(dispatch, firebase, userProfileSnap, token);\n    }) : handleProfileWatchResponse(dispatch, firebase, userProfileSnap, null);\n  }, createProfileWatchErrorHandler(dispatch, firebase));else throw new Error(\"Real Time Database or Firestore must be included to enable user profile\");\n};\n\nexports.watchUserProfile = watchUserProfile;\n\nvar createUserProfile = function (dispatch, firebase, userData, profile) {\n  var config = firebase._.config;\n  if (!config.userProfile || !firebase.database && !firebase.firestore) return Promise.resolve(userData);\n  if (\"function\" == typeof config.profileFactory) try {\n    profile = config.profileFactory(userData, profile, firebase);\n  } catch (err) {\n    return console.error(\"Error occurred within profileFactory function:\", err.message || err), Promise.reject(err);\n  }\n  return config.useFirestoreForProfile ? firebase.firestore().collection(config.userProfile).doc(userData.uid || userData.user.uid).get().then(function (profileSnap) {\n    if (!config.updateProfileOnLogin && profileSnap.exists) return profileSnap.data();\n    var newProfile = profile;\n\n    if (!newProfile) {\n      var userDataObject = userData.uid ? userData.toJSON ? userData.toJSON() : userData : userData.user.toJSON ? userData.user.toJSON() : userData.user;\n      newProfile = _objectSpread({}, (0, _omit2.default)(userDataObject, config.keysToRemoveFromAuth), {\n        avatarUrl: userDataObject.photoURL\n      });\n    }\n\n    return Array.isArray(newProfile.providerData) && (newProfile.providerData = newProfile.providerData.map(function (providerDataItem) {\n      return (0, _pick2.default)(providerDataItem, config.keysToPreserveFromProviderData);\n    })), profileSnap.ref.set(newProfile, {\n      merge: !0\n    }).then(function () {\n      return newProfile;\n    });\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), Promise.reject(err);\n  }) : firebase.database().ref().child(\"\".concat(config.userProfile, \"/\").concat(userData.user ? userData.user.uid : userData.uid)).once(\"value\").then(function (profileSnap) {\n    return config.updateProfileOnLogin || null === profileSnap.val() ? profileSnap.ref.update(profile).then(function () {\n      return profile;\n    }) : profileSnap.val();\n  }).catch(function (err) {\n    return dispatch({\n      type: _constants.actionTypes.UNAUTHORIZED_ERROR,\n      authError: err\n    }), \"function\" == typeof config.onProfileWriteError && config.onProfileWriteError(err, firebase), Promise.reject(err);\n  });\n};\n\nexports.createUserProfile = createUserProfile;\n\nvar handleAuthStateChange = function (dispatch, firebase, authData) {\n  var config = firebase._.config;\n  authData ? (firebase._.authUid = authData.uid, config.presence && (0, _auth.setupPresence)(dispatch, firebase), dispatch({\n    type: _constants.actionTypes.LOGIN,\n    auth: authData,\n    preserve: config.preserveOnLogin\n  }), watchUserProfile(dispatch, firebase), \"function\" == typeof config.onAuthStateChanged && config.onAuthStateChanged(authData, firebase, dispatch)) : (\"function\" == typeof config.onAuthStateChanged && firebase._.config.onAuthStateChanged(authData, firebase, dispatch), dispatch({\n    type: _constants.actionTypes.AUTH_EMPTY_CHANGE,\n    preserve: config.preserveOnEmptyAuthChange\n  }), unWatchUserProfile(firebase));\n},\n    handleRedirectResult = function (dispatch, firebase, authData) {\n  if (\"function\" == typeof firebase._.config.onRedirectResult && firebase._.config.onRedirectResult(authData, firebase, dispatch), authData && authData.user) {\n    var user = authData.user;\n    return firebase._.authUid = user.uid, watchUserProfile(dispatch, firebase), dispatch({\n      type: _constants.actionTypes.LOGIN,\n      auth: user,\n      preserve: firebase._.config.preserveOnLogin\n    }), createUserProfile(dispatch, firebase, user, {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    });\n  }\n};\n\nexports.handleRedirectResult = handleRedirectResult;\n\nvar init = function (dispatch, firebase) {\n  firebase.auth && (dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_STARTED\n  }), firebase.auth().onAuthStateChanged(function (authData) {\n    return handleAuthStateChange(dispatch, firebase, authData);\n  }), firebase._.config.enableRedirectHandling && \"function\" == typeof firebase.auth().getRedirectResult && \"undefined\" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf(\"http\") && firebase.auth().getRedirectResult().then(function (authData) {\n    return handleRedirectResult(dispatch, firebase, authData);\n  }).catch(function (error) {\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }), firebase.auth().currentUser, dispatch({\n    type: _constants.actionTypes.AUTHENTICATION_INIT_FINISHED\n  }));\n};\n\nexports.init = init;\n\nvar login = function (dispatch, firebase, credentials) {\n  var _firebase$auth;\n\n  firebase._.config.resetBeforeLogin && dispatchLoginError(dispatch, null);\n\n  var _getLoginMethodAndPar = (0, _auth.getLoginMethodAndParams)(firebase, credentials),\n      method = _getLoginMethodAndPar.method,\n      params = _getLoginMethodAndPar.params;\n\n  return (_firebase$auth = firebase.auth())[method].apply(_firebase$auth, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if ([\"signInWithEmailAndPassword\", \"signInAndRetrieveDataWithEmailAndPassword\"].includes(method)) return {\n      user: userData\n    };\n    if ([\"signInWithCustomToken\", \"signInAndRetrieveDataWithCustomToken\"].includes(method)) return firebase._.config.updateProfileOnLogin ? createUserProfile(dispatch, firebase, userData, credentials.profile) : {\n      user: userData\n    };\n    if (\"signInWithPhoneNumber\" === method) return _objectSpread({}, userData, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref) {\n          var user = _ref.user,\n              additionalUserInfo = _ref.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.login = login;\n\nvar reauthenticate = function (dispatch, firebase, credentials) {\n  var _firebase$auth$curren,\n      _getReauthenticateMet = (0, _auth.getReauthenticateMethodAndParams)(firebase, credentials),\n      method = _getReauthenticateMet.method,\n      params = _getReauthenticateMet.params;\n\n  return (_firebase$auth$curren = firebase.auth().currentUser)[method].apply(_firebase$auth$curren, _toConsumableArray(params)).then(function (userData) {\n    if (!userData) return Promise.resolve(null);\n    if (\"reauthenticateWithPhoneNumber\" === method) return _objectSpread({}, userData, {\n      confirm: function confirm(code) {\n        return userData.confirm(code).then(function (_ref2) {\n          var user = _ref2.user,\n              additionalUserInfo = _ref2.additionalUserInfo;\n          return createUserProfile(dispatch, firebase, user, {\n            phoneNumber: user.providerData[0].phoneNumber,\n            providerData: user.providerData\n          }).then(function (profile) {\n            return {\n              profile: profile,\n              user: user,\n              additionalUserInfo: additionalUserInfo\n            };\n          });\n        });\n      }\n    });\n    var user = userData.user || userData;\n    return createUserProfile(dispatch, firebase, user, credentials.profile || {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    }).then(function (profile) {\n      return _objectSpread({\n        profile: profile\n      }, userData);\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err, {\n      reauthenticate: !0\n    }), Promise.reject(err);\n  });\n};\n\nexports.reauthenticate = reauthenticate;\n\nvar logout = function (dispatch, firebase) {\n  return unWatchUserProfile(firebase), firebase.auth().signOut().then(function () {\n    var action = {\n      type: _constants.actionTypes.LOGOUT\n    };\n    return firebase._.config.preserveOnLogout && (action.preserve = firebase._.config.preserveOnLogout), dispatch(action), firebase._.authUid = null, firebase;\n  });\n};\n\nexports.logout = logout;\n\nvar createUser = function (dispatch, firebase, _ref3, profile) {\n  var email = _ref3.email,\n      password = _ref3.password;\n\n  if (dispatchLoginError(dispatch, null), !email || !password) {\n    var error = new Error(\"Email and Password are required to create user\");\n    return dispatchLoginError(dispatch, error), Promise.reject(error);\n  }\n\n  return firebase.auth().createUserWithEmailAndPassword(email, password).then(function (userData) {\n    return createUserProfile(dispatch, firebase, userData, profile || {\n      email: email\n    });\n  }).catch(function (err) {\n    return dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.createUser = createUser;\n\nvar resetPassword = function (dispatch, firebase, email) {\n  return dispatchLoginError(dispatch, null), firebase.auth().sendPasswordResetEmail(email).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, new Error(\"The specified user account does not exist.\"));\n          break;\n\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n\n      return Promise.reject(err);\n    }\n  });\n};\n\nexports.resetPassword = resetPassword;\n\nvar confirmPasswordReset = function (dispatch, firebase, code, password) {\n  return dispatchLoginError(dispatch, null), firebase.auth().confirmPasswordReset(code, password).catch(function (err) {\n    if (err) {\n      switch (err.code) {\n        case \"auth/expired-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code has expired.\"));\n          break;\n\n        case \"auth/invalid-action-code\":\n          dispatchLoginError(dispatch, new Error(\"The action code is invalid.\"));\n          break;\n\n        case \"auth/user-disabled\":\n          dispatchLoginError(dispatch, new Error(\"The user is disabled.\"));\n          break;\n\n        case \"auth/user-not-found\":\n          dispatchLoginError(dispatch, new Error(\"The user is not found.\"));\n          break;\n\n        case \"auth/weak-password\":\n          dispatchLoginError(dispatch, new Error(\"The password is not strong enough.\"));\n          break;\n\n        default:\n          dispatchLoginError(dispatch, err);\n      }\n\n      return Promise.reject(err);\n    }\n  });\n};\n\nexports.confirmPasswordReset = confirmPasswordReset;\n\nvar verifyPasswordResetCode = function (dispatch, firebase, code) {\n  return dispatchLoginError(dispatch, null), firebase.auth().verifyPasswordResetCode(code).catch(function (err) {\n    return err && dispatchLoginError(dispatch, err), Promise.reject(err);\n  });\n};\n\nexports.verifyPasswordResetCode = verifyPasswordResetCode;\n\nvar updateProfile = function (dispatch, firebase, profileUpdate, options) {\n  var config = firebase._.config;\n  dispatch({\n    type: _constants.actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  });\n  var updatePromise = config.useFirestoreForProfile ? _auth.updateProfileOnFirestore : _auth.updateProfileOnRTDB;\n  return updatePromise(firebase, profileUpdate, options).then(function (snap) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_SUCCESS,\n      payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n    }), snap;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.PROFILE_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateProfile = updateProfile;\n\nvar updateAuth = function (dispatch, firebase, authUpdate, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_UPDATE_START,\n    payload: authUpdate\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      payload: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.updateProfile(authUpdate).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_SUCCESS,\n      auth: firebase.auth().currentUser\n    }), updateInProfile ? updateProfile(dispatch, firebase, authUpdate) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateAuth = updateAuth;\n\nvar updateEmail = function (dispatch, firebase, newEmail, updateInProfile) {\n  if (dispatch({\n    type: _constants.actionTypes.EMAIL_UPDATE_START,\n    payload: newEmail\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to update email.\");\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.updateEmail(newEmail).then(function (payload) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_SUCCESS,\n      payload: newEmail\n    }), updateInProfile ? updateProfile(dispatch, firebase, {\n      email: newEmail\n    }) : payload;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.updateEmail = updateEmail;\n\nvar reloadAuth = function (dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_RELOAD_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to reload auth.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.reload().then(function () {\n    var auth = firebase.auth().currentUser;\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_RELOAD_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.reloadAuth = reloadAuth;\n\nvar linkWithCredential = function (dispatch, firebase, credential) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return firebase.auth().currentUser.linkWithCredential(credential).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n};\n\nexports.linkWithCredential = linkWithCredential;\n\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  if (dispatch({\n    type: _constants.actionTypes.AUTH_LINK_START\n  }), !firebase.auth().currentUser) {\n    var error = new Error(\"User must be logged in to link with credential.\");\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  }\n\n  return promiseFunc.apply(void 0, _toConsumableArray(args)).then(function (auth) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_SUCCESS,\n      payload: auth\n    }), auth;\n  }).catch(function (error) {\n    return dispatch({\n      type: _constants.actionTypes.AUTH_LINK_ERROR,\n      error: error\n    }), Promise.reject(error);\n  });\n}\n\nfunction linkAndRetrieveDataWithCredential(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkAndRetrieveDataWithCredential, [credential], dispatch, firebase);\n}\n\nfunction linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithPopup, [credential], dispatch, firebase);\n}\n\nfunction linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(firebase.auth().currentUser.linkWithRedirect, [provider], dispatch, firebase);\n}\n\nfunction signInWithPhoneNumber(firebase, dispatch, phoneNumber, applicationVerifier) {\n  var options = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : {};\n  return login(dispatch, firebase, _objectSpread({\n    phoneNumber: phoneNumber,\n    applicationVerifier: applicationVerifier\n  }, options));\n}","map":{"version":3,"sources":["../../src/actions/auth.js"],"names":["params","dispatch","type","actionTypes","authError","authUid","userProfile","useFirestoreForProfile","firebase","snap","profileParamsToPopulate","autoPopulateProfile","logErrors","profile","getProfileFromSnap","Array","console","token","userProfileSnap","path","data","timestamp","Date","requesting","requested","populates","err","onProfileListenerError","factoryResult","Promise","watchUserProfile","enableClaims","unWatchUserProfile","handleProfileWatchResponse","createProfileWatchErrorHandler","createUserProfile","config","userData","profileSnap","newProfile","userDataObject","avatarUrl","merge","onProfileWriteError","handleAuthStateChange","authData","preserve","auth","handleRedirectResult","onRedirectResult","user","uid","email","displayName","providerData","init","window","dispatchLoginError","login","method","credentials","confirm","additionalUserInfo","phoneNumber","reauthenticate","logout","action","preserveOnLogout","createUser","password","error","resetPassword","confirmPasswordReset","verifyPasswordResetCode","updateProfile","payload","updatePromise","updateProfileOnFirestore","updateProfileOnRTDB","updateAuth","updateInProfile","updateEmail","reloadAuth","linkWithCredential","promiseFunc","linkWithAuthDispatch","options","applicationVerifier"],"mappings":"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","sourcesContent":["import { forEach, omit, pick } from 'lodash'\nimport { actionTypes } from '../constants'\nimport { populate } from '../helpers'\nimport { isString } from '../utils'\nimport {\n  getLoginMethodAndParams,\n  getReauthenticateMethodAndParams,\n  updateProfileOnRTDB,\n  updateProfileOnFirestore,\n  setupPresence\n} from '../utils/auth'\nimport { promisesForPopulate, getPopulateObjs } from '../utils/populate'\n\n/**\n * Dispatch login error action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} authError - Error object\n * @param {object} params - Supplement action params\n * @returns {any} Return of action dispatch\n * @private\n */\nfunction dispatchLoginError(dispatch, authError, params = {}) {\n  return dispatch({\n    type: actionTypes.LOGIN_ERROR,\n    ...params,\n    authError\n  })\n}\n\n/**\n * Remove listener from user profile\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function unWatchUserProfile(firebase) {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile }\n  } = firebase._\n  if (firebase._.profileWatch) {\n    if (useFirestoreForProfile && firebase.firestore) {\n      // Call profile onSnapshot unsubscribe stored on profileWatch\n      firebase._.profileWatch()\n    } else {\n      firebase\n        .database()\n        .ref()\n        .child(`${userProfile}/${authUid}`)\n        .off('value', firebase._.profileWatch)\n    }\n    firebase._.profileWatch = null\n  }\n}\n\n/**\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} snap - Profile snapshot\n * @returns {object|null} Profile from snapshot\n */\nfunction getProfileFromSnap(snap) {\n  // Real Time Database\n  if (snap && snap.val) {\n    return snap.val()\n  }\n  // Firestore\n  if (snap && snap.data && snap.exists) {\n    return snap.data()\n  }\n  return null\n}\n\n/**\n * Handle response from profile listener. Works with both Real Time Database\n * and Cloud Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {firebase.database.Snapshot|firebase.firestore.DocumentSnapshot} userProfileSnap - Snapshot from profile watcher\n * @param {string} token - Token to pass along in action dispatch\n * @private\n */\nexport function handleProfileWatchResponse(\n  dispatch,\n  firebase,\n  userProfileSnap,\n  token\n) {\n  const {\n    profileParamsToPopulate,\n    autoPopulateProfile,\n    useFirestoreForProfile,\n    logErrors\n  } = firebase._.config\n  const profile = getProfileFromSnap(userProfileSnap)\n  if (\n    !profileParamsToPopulate ||\n    useFirestoreForProfile || // populating profile through firestore not yet supported\n    (!Array.isArray(profileParamsToPopulate) &&\n      !isString(profileParamsToPopulate))\n  ) {\n    if (useFirestoreForProfile && profileParamsToPopulate) {\n      console.warn('Profile population is not yet supported for Firestore') // eslint-disable-line no-console\n    }\n    dispatch({\n      type: actionTypes.SET_PROFILE,\n      profile: token ? { ...profile, token } : profile\n    })\n  } else {\n    // Convert array of populate config into an array of once query promises\n    promisesForPopulate(\n      firebase,\n      userProfileSnap.key,\n      profile,\n      profileParamsToPopulate\n    )\n      .then(data => {\n        // Fire actions for placement of data gathered in populate into redux\n        forEach(data, (result, path) => {\n          dispatch({\n            type: actionTypes.SET,\n            path,\n            data: result,\n            timestamp: Date.now(),\n            requesting: false,\n            requested: true\n          })\n        })\n        if (!autoPopulateProfile) {\n          // Dispatch action with profile combined with populated parameters\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: token ? { ...profile, token } : profile\n          })\n        } else {\n          // Auto Populate profile\n          const populates = getPopulateObjs(profileParamsToPopulate)\n          const profile = userProfileSnap.val()\n          dispatch({\n            type: actionTypes.SET_PROFILE,\n            profile: populate(\n              { profile: token ? { ...profile, token } : profile, data },\n              'profile',\n              populates\n            )\n          })\n        }\n      })\n      .catch(err => {\n        if (logErrors) {\n          // eslint-disable-next-line no-console\n          console.error(\n            `RRF: Error retrieving data for profile population. Firebase:`,\n            err\n          )\n        }\n        // Error retrieving data for population onto profile.\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          authError: `Error during profile population: ${err.message}`\n        })\n        // Update profile with un-populated version\n        dispatch({ type: actionTypes.SET_PROFILE, profile })\n      })\n  }\n}\n\n/**\n * Creates a function for handling errors from profile watcher. Used for\n * both RTDB and Firestore.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Function} Profile watch error handler function\n * @private\n */\nfunction createProfileWatchErrorHandler(dispatch, firebase) {\n  const { config: { onProfileListenerError, logErrors } } = firebase._\n  return function handleProfileError(err) {\n    if (logErrors) {\n      // eslint-disable-next-line no-console\n      console.error(`Error with profile listener: ${err.message || ''}`, err)\n    }\n    if (typeof onProfileListenerError === 'function') {\n      const factoryResult = onProfileListenerError(err, firebase)\n      // Return factoryResult if it is a promise\n      if (typeof factoryResult.then === 'function') {\n        return factoryResult\n      }\n    }\n    return Promise.reject(err)\n  }\n}\n\n/**\n * Watch user profile. Internally dispatches sets firebase._.profileWatch\n * and calls SET_PROFILE actions. Supports both Realtime Database and Firestore\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const watchUserProfile = (dispatch, firebase) => {\n  const {\n    authUid,\n    config: { userProfile, useFirestoreForProfile, enableClaims }\n  } = firebase._\n  unWatchUserProfile(firebase)\n\n  if (userProfile) {\n    if (useFirestoreForProfile && firebase.firestore) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .firestore()\n        .collection(userProfile)\n        .doc(authUid)\n        .onSnapshot(userProfileSnap => {\n          return enableClaims\n            ? firebase\n                .auth()\n                .currentUser.getIdTokenResult(true)\n                .then(token =>\n                  handleProfileWatchResponse(\n                    dispatch,\n                    firebase,\n                    userProfileSnap,\n                    token\n                  )\n                )\n            : handleProfileWatchResponse(\n                dispatch,\n                firebase,\n                userProfileSnap,\n                null\n              )\n        }, createProfileWatchErrorHandler(dispatch, firebase))\n    } else if (firebase.database) {\n      firebase._.profileWatch = firebase // eslint-disable-line no-param-reassign\n        .database()\n        .ref()\n        .child(`${userProfile}/${authUid}`)\n        .on(\n          'value',\n          userProfileSnap => {\n            enableClaims\n              ? firebase\n                  .auth()\n                  .currentUser.getIdTokenResult(true)\n                  .then(token =>\n                    handleProfileWatchResponse(\n                      dispatch,\n                      firebase,\n                      userProfileSnap,\n                      token\n                    )\n                  )\n              : handleProfileWatchResponse(\n                  dispatch,\n                  firebase,\n                  userProfileSnap,\n                  null\n                )\n          },\n          createProfileWatchErrorHandler(dispatch, firebase)\n        )\n    } else {\n      throw new Error(\n        'Real Time Database or Firestore must be included to enable user profile'\n      )\n    }\n  }\n}\n\n/**\n * Create user profile if it does not already exist.\n * `updateProfileOnLogin: false` can be passed to config to disable updating.\n * Profile factory is applied if it exists and is a function.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} userData - User data object (response from authenticating)\n * @param {object} profile - Profile data to place in new profile\n * @returns {Promise} Resolves after creating user profile\n * @private\n */\nexport const createUserProfile = (dispatch, firebase, userData, profile) => {\n  const { _: { config } } = firebase\n  if (!config.userProfile || (!firebase.database && !firebase.firestore)) {\n    return Promise.resolve(userData)\n  }\n  // use profileFactory if it exists in config\n  if (typeof config.profileFactory === 'function') {\n    // catch errors in user provided profileFactory function\n    try {\n      profile = config.profileFactory(userData, profile, firebase) // eslint-disable-line no-param-reassign\n    } catch (err) {\n      /* eslint-disable no-console */\n      console.error(\n        'Error occurred within profileFactory function:',\n        err.message || err\n      )\n      /* eslint-enable no-console */\n      return Promise.reject(err)\n    }\n  }\n\n  // Check/Write profile using Firestore\n  if (config.useFirestoreForProfile) {\n    // Check for user's profile at userProfile path if provided\n    return firebase\n      .firestore()\n      .collection(config.userProfile)\n      .doc(userData.uid || userData.user.uid)\n      .get()\n      .then(profileSnap => {\n        // Return if config for updating profile is not enabled and profile exists\n        if (!config.updateProfileOnLogin && profileSnap.exists) {\n          return profileSnap.data()\n        }\n        let newProfile = profile\n\n        // If the user did supply a profileFactory, we should use the result of it for the new Profile\n        if (!newProfile) {\n          // Convert to JSON format (to prevent issue of writing invalid type to Firestore)\n          const userDataObject = userData.uid\n            ? userData.toJSON ? userData.toJSON() : userData\n            : userData.user.toJSON ? userData.user.toJSON() : userData.user\n          // Remove unnecessary auth params (configurable) and preserve types of timestamps\n          newProfile = {\n            ...omit(userDataObject, config.keysToRemoveFromAuth),\n            avatarUrl: userDataObject.photoURL // match profile pattern used for RTDB\n          }\n        }\n\n        // Convert custom object type within Provider data to a normal object\n        if (Array.isArray(newProfile.providerData)) {\n          newProfile.providerData = newProfile.providerData.map(\n            providerDataItem =>\n              pick(providerDataItem, config.keysToPreserveFromProviderData)\n          )\n        }\n\n        // Create/Update the profile\n        return profileSnap.ref\n          .set(newProfile, { merge: true })\n          .then(() => newProfile)\n      })\n      .catch(err => {\n        // Error reading user profile\n        dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n        return Promise.reject(err)\n      })\n  }\n\n  // Check/Write profile using Firebase RTDB\n  return firebase\n    .database()\n    .ref()\n    .child(\n      `${config.userProfile}/${\n        userData.user ? userData.user.uid : userData.uid\n      }`\n    )\n    .once('value')\n    .then(\n      profileSnap =>\n        // update profile only if doesn't exist or if set by config\n        !config.updateProfileOnLogin && profileSnap.val() !== null\n          ? profileSnap.val()\n          : profileSnap.ref.update(profile).then(() => profile) // Update the profile\n    )\n    .catch(err => {\n      // Error reading user profile\n      dispatch({ type: actionTypes.UNAUTHORIZED_ERROR, authError: err })\n      if (typeof config.onProfileWriteError === 'function') {\n        config.onProfileWriteError(err, firebase)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Auth state change handler. Handles response from firebase's onAuthStateChanged\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from firebase's onAuthStateChanged\n * @private\n */\nconst handleAuthStateChange = (dispatch, firebase, authData) => {\n  const { config } = firebase._\n  if (!authData) {\n    // Run onAuthStateChanged if it exists in config and enableEmptyAuthChanges is set to true\n    if (typeof config.onAuthStateChanged === 'function') {\n      firebase._.config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n    dispatch({\n      type: actionTypes.AUTH_EMPTY_CHANGE,\n      preserve: config.preserveOnEmptyAuthChange\n    })\n\n    unWatchUserProfile(firebase)\n  } else {\n    firebase._.authUid = authData.uid // eslint-disable-line no-param-reassign\n\n    // setup presence if settings and database exist\n    if (config.presence) {\n      setupPresence(dispatch, firebase)\n    }\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: authData,\n      preserve: config.preserveOnLogin\n    })\n\n    watchUserProfile(dispatch, firebase)\n\n    // Run onAuthStateChanged if it exists in config\n    if (typeof config.onAuthStateChanged === 'function') {\n      config.onAuthStateChanged(authData, firebase, dispatch)\n    }\n  }\n}\n\n/**\n * Redirect result handler\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param  {object} authData - Auth data from Firebase's getRedirectResult\n * @returns {void}\n * @private\n */\nexport const handleRedirectResult = (dispatch, firebase, authData) => {\n  // Run onRedirectResult if it exists in config\n  if (typeof firebase._.config.onRedirectResult === 'function') {\n    firebase._.config.onRedirectResult(authData, firebase, dispatch)\n  }\n  if (authData && authData.user) {\n    const { user } = authData\n\n    firebase._.authUid = user.uid // eslint-disable-line no-param-reassign\n    watchUserProfile(dispatch, firebase)\n\n    dispatch({\n      type: actionTypes.LOGIN,\n      auth: user,\n      preserve: firebase._.config.preserveOnLogin\n    })\n\n    return createUserProfile(dispatch, firebase, user, {\n      email: user.email,\n      displayName: user.providerData[0].displayName || user.email,\n      avatarUrl: user.providerData[0].photoURL,\n      providerData: user.providerData\n    })\n  }\n}\n\n/**\n * Initialize authentication state change listener that\n * watches user profile and dispatches login action\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport const init = (dispatch, firebase) => {\n  // exit if auth does not exist\n  if (!firebase.auth) {\n    return\n  }\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_STARTED })\n  // Set Auth State listener\n  firebase\n    .auth()\n    .onAuthStateChanged(authData =>\n      handleAuthStateChange(dispatch, firebase, authData)\n    )\n\n  // set redirect result callback if enableRedirectHandling set to true\n  if (\n    firebase._.config.enableRedirectHandling &&\n    typeof firebase.auth().getRedirectResult === 'function' &&\n    (typeof window !== 'undefined' &&\n      window.location &&\n      window.location.protocol &&\n      window.location.protocol.indexOf('http') !== -1)\n  ) {\n    firebase\n      .auth()\n      .getRedirectResult()\n      .then(authData => handleRedirectResult(dispatch, firebase, authData))\n      .catch(error => {\n        dispatchLoginError(dispatch, error)\n        return Promise.reject(error)\n      })\n  }\n\n  firebase.auth().currentUser // eslint-disable-line no-unused-expressions\n\n  dispatch({ type: actionTypes.AUTHENTICATION_INIT_FINISHED })\n}\n\n/**\n * Login with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.email - Email to login with (only needed for email login)\n * @param {object} credentials.password - Password to login with (only needed for email login)\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {object} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const login = (dispatch, firebase, credentials) => {\n  if (firebase._.config.resetBeforeLogin) {\n    dispatchLoginError(dispatch, null)\n  }\n\n  const { method, params } = getLoginMethodAndParams(firebase, credentials)\n\n  return firebase\n    .auth()\n    [method](...params)\n    .then(userData => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      // For email auth return uid (createUser is used for creating a profile)\n      if (\n        [\n          'signInWithEmailAndPassword',\n          'signInAndRetrieveDataWithEmailAndPassword'\n        ].includes(method)\n      ) {\n        return { user: userData }\n      }\n      // TODO: Only call createUserProfile once, and just pass different settings\n\n      // For token auth, the user key doesn't exist. Instead, return the JWT.\n      if (\n        [\n          'signInWithCustomToken',\n          'signInAndRetrieveDataWithCustomToken'\n        ].includes(method)\n      ) {\n        if (!firebase._.config.updateProfileOnLogin) {\n          return { user: userData }\n        }\n        return createUserProfile(\n          dispatch,\n          firebase,\n          userData,\n          credentials.profile\n        )\n      }\n\n      if (method === 'signInWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: code =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then(profile => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then(profile => ({ profile, ...userData }))\n    })\n    .catch(err => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Reauthenticate with errors dispatched\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {object} credentials.provider - Provider name such as google, twitter (only needed for 3rd party provider login)\n * @param {object} credentials.type - Popup or redirect (only needed for 3rd party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider (i.e. email)\n * @returns {Promise} Resolves after user is logged in\n * @private\n */\nexport const reauthenticate = (dispatch, firebase, credentials) => {\n  const { method, params } = getReauthenticateMethodAndParams(\n    firebase,\n    credentials\n  )\n\n  return firebase\n    .auth()\n    .currentUser[method](...params)\n    .then(userData => {\n      // Handle null response from getRedirectResult before redirect has happened\n      if (!userData) return Promise.resolve(null)\n\n      if (method === 'reauthenticateWithPhoneNumber') {\n        // Modify confirm method to include profile creation\n        return {\n          ...userData,\n          confirm: code =>\n            // Call original confirm\n            userData.confirm(code).then(({ user, additionalUserInfo }) =>\n              createUserProfile(dispatch, firebase, user, {\n                phoneNumber: user.providerData[0].phoneNumber,\n                providerData: user.providerData\n              }).then(profile => ({ profile, user, additionalUserInfo }))\n            )\n        }\n      }\n\n      // Create profile when logging in with external provider\n      const user = userData.user || userData\n\n      return createUserProfile(\n        dispatch,\n        firebase,\n        user,\n        credentials.profile || {\n          email: user.email,\n          displayName: user.providerData[0].displayName || user.email,\n          avatarUrl: user.providerData[0].photoURL,\n          providerData: user.providerData\n        }\n      ).then(profile => ({ profile, ...userData }))\n    })\n    .catch(err => {\n      dispatchLoginError(dispatch, err, { reauthenticate: true })\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Logout of firebase and dispatch logout event\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after logging out\n * @private\n */\nexport const logout = (dispatch, firebase) => {\n  // detach profile listener before logging out to prevent permission_denied\n  // errors (for more info see #494)\n  unWatchUserProfile(firebase)\n  return firebase\n    .auth()\n    .signOut()\n    .then(() => {\n      const action = {\n        type: actionTypes.LOGOUT\n      }\n      if (firebase._.config.preserveOnLogout) {\n        action.preserve = firebase._.config.preserveOnLogout\n      }\n      dispatch(action)\n      firebase._.authUid = null\n      return firebase\n    })\n}\n\n/**\n * Create a new user in auth and add an account to userProfile root\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email of user\n * @param {string} credentials.password - Password of new user\n * @param {object} profile - Profile to store in database for new user\n * @returns {Promise} Resolves after user is created\n * @private\n */\nexport const createUser = (\n  dispatch,\n  firebase,\n  { email, password },\n  profile\n) => {\n  dispatchLoginError(dispatch, null)\n\n  if (!email || !password) {\n    const error = new Error('Email and Password are required to create user')\n    dispatchLoginError(dispatch, error)\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .createUserWithEmailAndPassword(email, password)\n    .then(userData =>\n      // Login to newly created account flag is not set to false\n      createUserProfile(dispatch, firebase, userData, profile || { email })\n    )\n    .catch(err => {\n      dispatchLoginError(dispatch, err)\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Send password reset email to provided email\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} email - Email to send recovery email to\n * @returns {Promise} Resolves after password reset email is sent\n * @private\n */\nexport const resetPassword = (dispatch, firebase, email) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .sendPasswordResetEmail(email)\n    .catch(err => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/user-not-found':\n            dispatchLoginError(\n              dispatch,\n              new Error('The specified user account does not exist.')\n            )\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Confirm the password reset with code and password\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Email confirmation reset code\n * @param {string} password - Password to set it to\n * @returns {Promise} Resvoles after password reset is confirmed\n * @private\n */\nexport const confirmPasswordReset = (dispatch, firebase, code, password) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .confirmPasswordReset(code, password)\n    .catch(err => {\n      if (err) {\n        switch (err.code) {\n          case 'auth/expired-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code has expired.')\n            )\n            break\n          case 'auth/invalid-action-code':\n            dispatchLoginError(\n              dispatch,\n              new Error('The action code is invalid.')\n            )\n            break\n          case 'auth/user-disabled':\n            dispatchLoginError(dispatch, new Error('The user is disabled.'))\n            break\n          case 'auth/user-not-found':\n            dispatchLoginError(dispatch, new Error('The user is not found.'))\n            break\n          case 'auth/weak-password':\n            dispatchLoginError(\n              dispatch,\n              new Error('The password is not strong enough.')\n            )\n            break\n          default:\n            dispatchLoginError(dispatch, err)\n        }\n        return Promise.reject(err)\n      }\n    })\n}\n\n/**\n * Verify that password reset code is valid\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} code - Password reset code\n * @returns {Promise} email - Email associated with reset code\n * @private\n */\nexport const verifyPasswordResetCode = (dispatch, firebase, code) => {\n  dispatchLoginError(dispatch, null)\n  return firebase\n    .auth()\n    .verifyPasswordResetCode(code)\n    .catch(err => {\n      if (err) {\n        dispatchLoginError(dispatch, err)\n      }\n      return Promise.reject(err)\n    })\n}\n\n/**\n * Update user profile\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} profileUpdate - Update for profile\n * @param {object} options - Options object\n * @returns {Promise} Resolves after updating profile\n * @private\n */\nexport const updateProfile = (dispatch, firebase, profileUpdate, options) => {\n  const { _: { config } } = firebase\n  dispatch({\n    type: actionTypes.PROFILE_UPDATE_START,\n    payload: profileUpdate\n  })\n  // Select update promise type (firebase/firestore) based on config\n  const updatePromise = config.useFirestoreForProfile\n    ? updateProfileOnFirestore\n    : updateProfileOnRTDB\n  return updatePromise(firebase, profileUpdate, options)\n    .then(snap => {\n      dispatch({\n        type: actionTypes.PROFILE_UPDATE_SUCCESS,\n        payload: config.useFirestoreForProfile ? snap.data() : snap.val()\n      })\n      return snap\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.PROFILE_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update Auth Profile Object. Internally calls\n * `firebase.auth().currentUser.updateProfile` as seen [in the firebase docs](https://firebase.google.com/docs/auth/web/manage-users#update_a_users_profile).\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} authUpdate - Update for current user's auth profile\n * @param {boolean} updateInProfile - Whether or not to update in profile as well\n * @returns {Promise} Resolves with results of updating auth\n * @private\n */\nexport const updateAuth = (dispatch, firebase, authUpdate, updateInProfile) => {\n  dispatch({ type: actionTypes.AUTH_UPDATE_START, payload: authUpdate })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update auth.')\n    dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, payload: error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateProfile(authUpdate)\n    .then(payload => {\n      dispatch({\n        type: actionTypes.AUTH_UPDATE_SUCCESS,\n        auth: firebase.auth().currentUser\n      })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, authUpdate)\n      }\n      return payload\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.AUTH_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Update user's email within Firebase auth and optionally within\n * users's profile. Internally calls `firebase.auth().currentUser.updateEmail`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {string} newEmail - Update to be auth object\n * @param {boolean} updateInProfile - Whether or not to update email within\n * user's profile object (stored under path provided to userProfile config)\n * @returns {Promise} Resolves with results of updating email\n * @private\n */\nexport const updateEmail = (dispatch, firebase, newEmail, updateInProfile) => {\n  dispatch({ type: actionTypes.EMAIL_UPDATE_START, payload: newEmail })\n\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to update email.')\n    dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.updateEmail(newEmail)\n    .then(payload => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_SUCCESS, payload: newEmail })\n      if (updateInProfile) {\n        return updateProfile(dispatch, firebase, { email: newEmail })\n      }\n      return payload\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.EMAIL_UPDATE_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Reload Auth state. Internally calls\n * `firebase.auth().currentUser.reload`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves with auth\n */\nexport const reloadAuth = (dispatch, firebase) => {\n  dispatch({ type: actionTypes.AUTH_RELOAD_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to reload auth.')\n    dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.reload()\n    .then(() => {\n      const auth = firebase.auth().currentUser\n      dispatch({ type: actionTypes.AUTH_RELOAD_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.AUTH_RELOAD_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport const linkWithCredential = (dispatch, firebase, credential) => {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return firebase\n    .auth()\n    .currentUser.linkWithCredential(credential)\n    .then(auth => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * @param {Function} promiseFunc - Promise function\n * @param {Array} args - arguments to pass to function\n * @param {Function} dispatch - Redux dispatch function\n * @param {object} firebase - Internal firebase object\n * @returns {Promise} Resolves after auth is linked and AUTH_LINK_SUCCESS\n * action is dispatched\n */\nfunction linkWithAuthDispatch(promiseFunc, args, dispatch, firebase) {\n  dispatch({ type: actionTypes.AUTH_LINK_START })\n\n  // reject and dispatch error if not logged in\n  if (!firebase.auth().currentUser) {\n    const error = new Error('User must be logged in to link with credential.')\n    dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n    return Promise.reject(error)\n  }\n\n  return promiseFunc(...args)\n    .then(auth => {\n      dispatch({ type: actionTypes.AUTH_LINK_SUCCESS, payload: auth })\n      return auth\n    })\n    .catch(error => {\n      dispatch({ type: actionTypes.AUTH_LINK_ERROR, error })\n      return Promise.reject(error)\n    })\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkAndRetrieveDataWithCredential`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkAndRetrieveDataWithCredential(\n  dispatch,\n  firebase,\n  credential\n) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkAndRetrieveDataWithCredential,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithPopup`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} credential - Credential with which to link user account\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithPopup(dispatch, firebase, credential) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithPopup,\n    [credential],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Links the user account with the given credentials. Internally\n * calls `firebase.auth().currentUser.linkWithRedirect`.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {any} provider - Auth provider\n * @returns {Promise} Resolves with auth\n */\nexport function linkWithRedirect(dispatch, firebase, provider) {\n  return linkWithAuthDispatch(\n    firebase.auth().currentUser.linkWithRedirect,\n    [provider],\n    dispatch,\n    firebase\n  )\n}\n\n/**\n * Asynchronously signs in using a phone number and create's\n * user profile. This method sends a code via SMS to the given phone\n * number, and returns a firebase.auth.ConfirmationResult. Internally\n * calls `firebase.auth().signInWithPhoneNumber`.\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} phoneNumber - Phone number\n * @param {object} applicationVerifier - Phone number\n * @param {object} options - Options object\n * @returns {Promise} Resolves with auth\n */\nexport function signInWithPhoneNumber(\n  firebase,\n  dispatch,\n  phoneNumber,\n  applicationVerifier,\n  options = {}\n) {\n  return login(dispatch, firebase, {\n    phoneNumber,\n    applicationVerifier,\n    ...options\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
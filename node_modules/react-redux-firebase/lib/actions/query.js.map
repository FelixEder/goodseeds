{"version":3,"sources":["../../src/actions/query.js"],"names":["watchEvent","firebase","dispatch","options","database","Error","type","path","populates","queryParams","queryId","isQuery","storeAs","logErrors","_","config","watchPath","id","counter","ref","child","orderByKey","limitToFirst","once","then","snapshot","val","actionTypes","NO_VALUE","catch","err","ERROR","payload","Promise","reject","query","START","data","SET","ordered","UNAUTHORIZED_ERROR","on","resultPath","key","value","console","log","unWatchEvent","watchEvents","events","Array","isArray","map","event","unWatchEvents","forEach","remove","dispatchAction","dispatchRemoveAction","REMOVE"],"mappings":"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","sourcesContent":["import { actionTypes } from '../constants'\nimport {\n  orderedFromSnapshot,\n  populateAndDispatch,\n  applyParamsToQuery,\n  getWatcherCount,\n  setWatcher,\n  unsetWatcher,\n  getQueryIdFromPath\n} from '../utils/query'\n\n/**\n * Watch a path in Firebase Real Time Database\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} options - Event options object\n * @param {string} options.type - Type of event to watch for (defaults to value)\n * @param {string} options.path - Path to watch with watcher\n * @param {Array} options.queryParams - List of parameters for the query\n * @param {string} options.queryId - id of the query\n * @param {boolean} options.isQuery - id of the query\n * @param {string} options.storeAs - Location within redux to store value\n * @returns {Promise|void} Returns promise if query is a promise\n */\nexport function watchEvent(firebase, dispatch, options) {\n  if (!firebase.database || typeof firebase.database !== 'function') {\n    throw new Error('Firebase database is required to create watchers')\n  }\n  const {\n    type,\n    path,\n    populates,\n    queryParams,\n    queryId,\n    isQuery,\n    storeAs\n  } = options\n  const { config: { logErrors } } = firebase._\n\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  const id = queryId || getQueryIdFromPath(path)\n  const counter = getWatcherCount(firebase, type, watchPath, id)\n\n  if (counter > 0) {\n    if (id) {\n      unsetWatcher(firebase, dispatch, type, path, id)\n    }\n  }\n\n  setWatcher(firebase, dispatch, type, watchPath, id)\n\n  if (type === 'first_child') {\n    return firebase\n      .database()\n      .ref()\n      .child(path)\n      .orderByKey()\n      .limitToFirst(1)\n      .once('value')\n      .then(snapshot => {\n        if (snapshot.val() === null) {\n          dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        return snapshot\n      })\n      .catch(err => {\n        dispatch({\n          type: actionTypes.ERROR,\n          path: storeAs || path,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n\n  let query = firebase\n    .database()\n    .ref()\n    .child(path)\n\n  if (isQuery) {\n    query = applyParamsToQuery(queryParams, query)\n  }\n\n  dispatch({ type: actionTypes.START, path: storeAs || path })\n\n  // Handle once queries\n  if (type === 'once') {\n    return query\n      .once('value')\n      .then(snapshot => {\n        if (snapshot.val() === null) {\n          return dispatch({\n            type: actionTypes.NO_VALUE,\n            path: storeAs || path\n          })\n        }\n        // dispatch normal event if no populates exist\n        if (!populates) {\n          // create an array for preserving order of children under ordered\n          return dispatch({\n            type: actionTypes.SET,\n            path: storeAs || path,\n            data: snapshot.val(),\n            ordered: orderedFromSnapshot(snapshot)\n          })\n        }\n        // populate and dispatch associated actions if populates exist\n        return populateAndDispatch(firebase, dispatch, {\n          path,\n          storeAs,\n          snapshot,\n          data: snapshot.val(),\n          populates\n        })\n      })\n      .catch(err => {\n        dispatch({\n          type: actionTypes.UNAUTHORIZED_ERROR,\n          payload: err\n        })\n        return Promise.reject(err)\n      })\n  }\n  // Handle all other queries\n\n  /* istanbul ignore next: is run by tests but doesn't show in coverage */\n  query.on(\n    type,\n    snapshot => {\n      let data = type === 'child_removed' ? undefined : snapshot.val()\n      const resultPath =\n        storeAs || type === 'value' ? path : `${path}/${snapshot.key}`\n\n      // Dispatch standard event if no populates exists\n      if (!populates) {\n        // create an array for preserving order of children under ordered\n        const ordered =\n          type === 'child_added'\n            ? [{ key: snapshot.key, value: snapshot.val() }]\n            : orderedFromSnapshot(snapshot)\n        return dispatch({\n          type: actionTypes.SET,\n          path: storeAs || resultPath,\n          data,\n          ordered\n        })\n      }\n      // populate and dispatch associated actions if populates exist\n      return populateAndDispatch(firebase, dispatch, {\n        path,\n        storeAs,\n        snapshot,\n        data: snapshot.val(),\n        populates\n      })\n    },\n    err => {\n      if (logErrors) {\n        // eslint-disable-next-line no-console\n        console.log(\n          `Error retrieving data for path: ${path}, storeAs: ${storeAs}. Firebase:`,\n          err\n        )\n      }\n      dispatch({\n        type: actionTypes.ERROR,\n        storeAs,\n        path,\n        payload: err\n      })\n    }\n  )\n}\n\n/**\n * Remove watcher from an event\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {object} config - Config object\n * @param {string} config.type - Type for which to remove the watcher (\n * value, once, first_child etc.)\n * @param {string} config.path - Path of watcher to remove\n * @param {string} config.storeAs - Path which to store results within in\n * redux store\n * @param {string} config.queryId - Id of the query (used for idendifying)\n * in internal watchers list\n */\nexport function unWatchEvent(\n  firebase,\n  dispatch,\n  { type, path, storeAs, queryId }\n) {\n  const watchPath = !storeAs ? path : `${path}@${storeAs}`\n  unsetWatcher(firebase, dispatch, type, watchPath, queryId)\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to add watchers\n * @returns {Array} ARray of watchEvent results\n */\nexport function watchEvents(firebase, dispatch, events) {\n  if (!Array.isArray(events)) {\n    throw new Error('Events config must be an Array')\n  }\n  return events.map(event => watchEvent(firebase, dispatch, event))\n}\n\n/**\n * Remove watchers from a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {Array} events - List of events for which to remove watchers\n */\nexport function unWatchEvents(firebase, dispatch, events) {\n  events.forEach(event => unWatchEvent(firebase, dispatch, event))\n}\n\n/**\n * Add watchers to a list of events\n * @param {object} firebase - Internal firebase object\n * @param {Function} dispatch - Action dispatch function\n * @param {string} path - Path of ref to be removed\n * @param {object} [options={}] - Configuration for removal\n * @param {boolean} [options.dispatchAction=true] - Whether or not to dispatch\n * REMOVE action\n * @returns {Promise} Resolves with path\n */\nexport function remove(firebase, dispatch, path, options = {}) {\n  const { dispatchAction = true } = options\n  const { dispatchRemoveAction } = firebase._.config\n  return firebase\n    .database()\n    .ref(path)\n    .remove()\n    .then(() => {\n      if (dispatchRemoveAction && dispatchAction) {\n        dispatch({ type: actionTypes.REMOVE, path })\n      }\n      return path\n    })\n    .catch(err => {\n      dispatch({ type: actionTypes.ERROR, payload: err })\n      return Promise.reject(err)\n    })\n}\n"],"file":"query.js"}
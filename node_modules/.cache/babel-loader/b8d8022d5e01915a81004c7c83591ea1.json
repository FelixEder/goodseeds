{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.pathStrToObj = pathStrToObj, exports.getEventsFromInput = getEventsFromInput, exports.default = void 0;\n\nvar _remove2 = _interopRequireDefault(require(\"lodash/remove\")),\n    _isObject2 = _interopRequireDefault(require(\"lodash/isObject\")),\n    _flatMap2 = _interopRequireDefault(require(\"lodash/flatMap\")),\n    _populate = require(\"./populate\"),\n    _query = require(\"./query\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction pathStrToObj(path) {\n  var pathObj = {\n    path: path,\n    type: \"value\",\n    isQuery: !1\n  },\n      queryId = (0, _query.getQueryIdFromPath)(path);\n\n  if (queryId) {\n    var pathArray = path.split(\"#\");\n    pathObj = Object.assign({}, pathObj, {\n      queryId: queryId,\n      isQuery: !0,\n      path: pathArray[0],\n      queryParams: pathArray[1].split(\"&\")\n    }), (0, _populate.getPopulates)(pathArray[1].split(\"&\")) && (pathObj.populates = (0, _populate.getPopulates)(pathArray[1].split(\"&\")), pathObj.queryParams = (0, _remove2.default)(pathArray[1].split(\"&\"), function (p) {\n      return -1 === p.indexOf(\"populate\");\n    }));\n  }\n\n  return pathObj;\n}\n\nfunction getEventsFromInput(paths) {\n  return (0, _flatMap2.default)(paths, function (path) {\n    if (\"string\" == typeof path || path instanceof String) return [pathStrToObj(path)];\n    if (Array.isArray(path)) return [{\n      type: \"first_child\",\n      path: path[0]\n    }, {\n      type: \"child_added\",\n      path: path[0]\n    }, {\n      type: \"child_removed\",\n      path: path[0]\n    }, {\n      type: \"child_moved\",\n      path: path[0]\n    }, {\n      type: \"child_changed\",\n      path: path[0]\n    }];\n\n    if ((0, _isObject2.default)(path)) {\n      if (!path.path) throw new Error(\"Path is a required parameter within definition object\");\n      var strPath = path.path;\n      return path.storeAs && (strPath += \"@\".concat(path.storeAs)), path.queryParams && (strPath += \"#\".concat(path.queryParams.join(\"&\"))), path = Object.assign({}, pathStrToObj(strPath), path), [path];\n    }\n\n    throw new Error(\"Invalid Path Definition: \".concat(path, \". Only strings, objects, and arrays accepted.\"));\n  });\n}\n\nvar _default = {\n  getEventsFromInput: getEventsFromInput\n};\nexports.default = _default;","map":{"version":3,"sources":["../../src/utils/events.js"],"names":["pathObj","path","type","isQuery","queryId","pathArray","Object","queryParams","pathStrToObj","Array","strPath","storeAs","getEventsFromInput"],"mappings":"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","sourcesContent":["import { flatMap, isObject, remove } from 'lodash'\nimport { getPopulates } from './populate'\nimport { getQueryIdFromPath } from './query'\n\n/**\n * @description Convert path string to object with queryParams, path, and populates\n * @param {string} path - Path that can contain query parameters and populates\n * @returns {object} watchEvents - Array of watch events\n */\nexport function pathStrToObj(path) {\n  let pathObj = { path, type: 'value', isQuery: false }\n  const queryId = getQueryIdFromPath(path)\n  // If Query id exists split params from path\n  if (queryId) {\n    const pathArray = path.split('#')\n    pathObj = Object.assign({}, pathObj, {\n      queryId,\n      isQuery: true,\n      path: pathArray[0],\n      queryParams: pathArray[1].split('&')\n    })\n    if (getPopulates(pathArray[1].split('&'))) {\n      pathObj.populates = getPopulates(pathArray[1].split('&'))\n      pathObj.queryParams = remove(\n        pathArray[1].split('&'),\n        p => p.indexOf('populate') === -1\n      )\n    }\n  }\n  // if queryId does not exist, return original pathObj\n  return pathObj\n}\n\n/**\n * @description Convert watch path definition array to watch events\n * @param {Array} paths - Array of path strings, objects, and arrays to watch\n * @returns {Array} watchEvents - Array of watch events\n */\nexport function getEventsFromInput(paths) {\n  return flatMap(paths, path => {\n    // If path is a string - convert to obj and place within new array\n    if (typeof path === 'string' || path instanceof String) {\n      return [pathStrToObj(path)]\n    }\n\n    if (Array.isArray(path)) {\n      // TODO: Handle input other than array with string\n      // TODO: Handle populates within array\n      return [\n        { type: 'first_child', path: path[0] },\n        { type: 'child_added', path: path[0] },\n        { type: 'child_removed', path: path[0] },\n        { type: 'child_moved', path: path[0] },\n        { type: 'child_changed', path: path[0] }\n      ]\n    }\n\n    if (isObject(path)) {\n      if (!path.path) {\n        throw new Error('Path is a required parameter within definition object')\n      }\n      let strPath = path.path\n\n      if (path.storeAs) {\n        // append storeAs to query path\n        strPath += `@${path.storeAs}`\n      }\n\n      if (path.queryParams) {\n        // append query params to path for queryId added in pathStrToObj\n        strPath += `#${path.queryParams.join('&')}`\n      }\n\n      // Add all parameters that are missing (ones that exist will remain)\n      path = Object.assign({}, pathStrToObj(strPath), path)\n      return [path]\n    }\n\n    throw new Error(\n      `Invalid Path Definition: ${path}. Only strings, objects, and arrays accepted.`\n    )\n  })\n}\n\nexport default { getEventsFromInput }\n"]},"metadata":{},"sourceType":"script"}
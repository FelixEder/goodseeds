{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","actionTypes","FILE_UPLOAD_PROGRESS","deleteFile","firebase","path","dbPath","storage","ref","delete","then","database","firestore","metaDeletePromise","_","config","useFirestoreForStorageMeta","doc","remove","createUploadMetaResponseHandler","fileData","uploadTaskSnapshot","downloadURL","metaDataSnapshot","result","snapshot","key","id","File","uploadTaskSnaphot","createdAt","FieldValue","serverTimestamp","ServerValue","TIMESTAMP","getDownloadURLFromUploadTaskSnapshot","getDownloadURL","Promise","resolve","downloadURLs","writeMetadataToDb","options","fileMetadataFactory","metadataFactory","metaFactoryFunction","metadata","resultFromSnap","metaSetPromise","collection","add","newMetaRef","push","set","uploadFileWithProgress","dispatch","file","filename","meta","fileMetadata","uploadEvent","put","unListen","on","TaskEvent","STATE_CHANGED","next","type","payload","percent","Math","floor","bytesTransferred","totalBytes","error","err","complete"],"mappings":"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","sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase\n              .firestore()\n              .doc(dbPath)\n              .delete() // file meta in Firestore\n          : firebase\n              .database()\n              .ref(dbPath)\n              .remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    downloadURL => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const metaSetPromise = fileData => {\n        if (useFirestoreForStorageMeta) {\n          return firebase // Write metadata to Firestore\n            .firestore()\n            .collection(dbPath)\n            .add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase\n          .database()\n          .ref(dbPath)\n          .push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then(res => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: snapshot => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            snapshot.bytesTransferred / snapshot.totalBytes * 100\n          )\n        }\n      })\n    },\n    error: err => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"],"file":"storage.js"}
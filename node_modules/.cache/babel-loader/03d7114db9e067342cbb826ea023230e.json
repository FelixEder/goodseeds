{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.getLoginMethodAndParams = getLoginMethodAndParams, exports.getReauthenticateMethodAndParams = getReauthenticateMethodAndParams, exports.authIsReady = authIsReady, exports.createAuthIsReady = createAuthIsReady, exports.updateProfileOnRTDB = updateProfileOnRTDB, exports.updateProfileOnFirestore = updateProfileOnFirestore, exports.setupPresence = setupPresence;\n\nvar _capitalize2 = _interopRequireDefault(require(\"lodash/capitalize\")),\n    _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction createAuthProvider(firebase, providerName, scopes) {\n  var capitalProviderName = \"\".concat((0, _capitalize2.default)(providerName), \"AuthProvider\");\n  if (!firebase.auth[capitalProviderName]) throw new Error(\"\".concat(providerName, \" is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.\"));\n  var provider = new firebase.auth[capitalProviderName](),\n      customAuthParameters = firebase._.config.customAuthParameters;\n  return (customAuthParameters && customAuthParameters[providerName] && provider.setCustomParameters(customAuthParameters[providerName]), \"twitter\" === providerName.toLowerCase() || \"function\" != typeof provider.addScope) ? provider : (provider.addScope(\"email\"), scopes && (Array.isArray(scopes) && scopes.forEach(function (scope) {\n    provider.addScope(scope);\n  }), (\"string\" == typeof scopes || scopes instanceof String) && provider.addScope(scopes)), provider);\n}\n\nfunction getLoginMethodAndParams(firebase, credentials) {\n  var email = credentials.email,\n      password = credentials.password,\n      provider = credentials.provider,\n      type = credentials.type,\n      token = credentials.token,\n      scopes = credentials.scopes,\n      phoneNumber = credentials.phoneNumber,\n      applicationVerifier = credentials.applicationVerifier,\n      credential = credentials.credential;\n\n  if (credential) {\n    var credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"signInAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"signInWithCredential\",\n      params: [credential]\n    };\n  }\n\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    if (token) throw new Error(\"provider with token no longer supported, use credential parameter instead\");\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"signInWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"signInWithRedirect\",\n      params: [authProvider]\n    };\n  }\n\n  if (token) {\n    var tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken;\n    return tokenAuth ? {\n      method: \"signInAndRetrieveDataWithCustomToken\",\n      params: [token]\n    } : {\n      method: \"signInWithCustomToken\",\n      params: [token]\n    };\n  }\n\n  if (phoneNumber) {\n    if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n    return {\n      method: \"signInWithPhoneNumber\",\n      params: [phoneNumber, applicationVerifier]\n    };\n  }\n\n  return firebase.auth().signInWithEmailAndPassword ? {\n    method: \"signInWithEmailAndPassword\",\n    params: [email, password]\n  } : {\n    method: \"signInAndRetrieveDataWithEmailAndPassword\",\n    params: [email, password]\n  };\n}\n\nfunction getReauthenticateMethodAndParams(firebase, credentials) {\n  var provider = credentials.provider,\n      type = credentials.type,\n      scopes = credentials.scopes,\n      phoneNumber = credentials.phoneNumber,\n      applicationVerifier = credentials.applicationVerifier,\n      credential = credentials.credential;\n\n  if (credential) {\n    var credentialAuth = firebase.auth().reauthenticateAndRetrieveDataWithCredential;\n    return credentialAuth ? {\n      method: \"reauthenticateAndRetrieveDataWithCredential\",\n      params: [credential]\n    } : {\n      method: \"reauthenticateWithCredential\",\n      params: [credential]\n    };\n  }\n\n  if (provider) {\n    if (-1 === _constants.supportedAuthProviders.indexOf(provider.toLowerCase())) throw new Error(\"\".concat(provider, \" is not a valid Auth Provider\"));\n    var authProvider = createAuthProvider(firebase, provider, scopes);\n    return \"popup\" === type ? {\n      method: \"reauthenticateWithPopup\",\n      params: [authProvider]\n    } : {\n      method: \"reauthenticateWithRedirect\",\n      params: [authProvider]\n    };\n  }\n\n  if (!applicationVerifier) throw new Error(\"Application verifier is required for phone authentication\");\n  return {\n    method: \"reauthenticateWithPhoneNumber\",\n    params: [phoneNumber, applicationVerifier]\n  };\n}\n\nfunction isAuthReady(store, stateName) {\n  var state = store.getState(),\n      firebaseState = stateName ? state[stateName] : state,\n      firebaseAuthState = firebaseState && firebaseState.auth;\n  if (!firebaseAuthState) throw new Error(\"The Firebase auth state could not be found in the store under the attribute '\".concat(stateName ? \"\".concat(stateName, \".\") : \"\", \"auth'. Make sure your react-redux-firebase reducer is correctly set in the store\"));\n  return firebaseState.auth.isLoaded;\n}\n\nfunction authIsReady(store) {\n  var stateName = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : \"firebase\";\n  return new Promise(function (resolve) {\n    if (isAuthReady(store, stateName)) resolve();else var unsubscribe = store.subscribe(function () {\n      isAuthReady(store, stateName) && (unsubscribe(), resolve());\n    });\n  });\n}\n\nfunction createAuthIsReady(store, config) {\n  return \"function\" == typeof config.authIsReady ? config.authIsReady(store, config) : authIsReady(store, config.firebaseStateName);\n}\n\nfunction updateProfileOnRTDB(firebase, profileUpdate) {\n  var _firebase$_ = firebase._,\n      config = _firebase$_.config,\n      authUid = _firebase$_.authUid,\n      profileRef = firebase.database().ref(\"\".concat(config.userProfile, \"/\").concat(authUid));\n  return profileRef.update(profileUpdate).then(function () {\n    return profileRef.once(\"value\");\n  });\n}\n\nfunction updateProfileOnFirestore(firebase, profileUpdate) {\n  var options = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {},\n      _options$useSet = options.useSet,\n      _options$merge = options.merge,\n      firestore = firebase.firestore,\n      _firebase$_2 = firebase._,\n      config = _firebase$_2.config,\n      authUid = _firebase$_2.authUid,\n      profileRef = firestore().doc(\"\".concat(config.userProfile, \"/\").concat(authUid)),\n      profileUpdatePromise = !(void 0 !== _options$useSet) || _options$useSet ? profileRef.set(profileUpdate, {\n    merge: !(void 0 !== _options$merge) || _options$merge\n  }) : profileRef.update(profileUpdate);\n  return profileUpdatePromise.then(function () {\n    return profileRef.get();\n  });\n}\n\nfunction setupPresence(dispatch, firebase) {\n  if (firebase.database && firebase.database.ServerValue) {\n    var ref = firebase.database().ref(),\n        _firebase$_3 = firebase._,\n        _firebase$_3$config = _firebase$_3.config,\n        presence = _firebase$_3$config.presence,\n        sessions = _firebase$_3$config.sessions,\n        authUid = _firebase$_3.authUid,\n        amOnline = ref.child(\".info/connected\"),\n        onlineRef = ref.child(\"function\" == typeof presence ? presence(firebase.auth().currentUser, firebase) : presence).child(authUid),\n        sessionsRef = \"function\" == typeof sessions ? sessions(firebase.auth().currentUser, firebase) : sessions;\n    sessionsRef && (sessionsRef = ref.child(sessions)), amOnline.on(\"value\", function (snapShot) {\n      if (snapShot.val()) {\n        if (sessionsRef) {\n          dispatch({\n            type: _constants.actionTypes.SESSION_START,\n            payload: authUid\n          });\n          var session = sessionsRef.push({\n            startedAt: firebase.database.ServerValue.TIMESTAMP,\n            user: authUid\n          });\n          \"function\" == typeof session.setPriority && session.setPriority(authUid), session.child(\"endedAt\").onDisconnect().set(firebase.database.ServerValue.TIMESTAMP, function () {\n            dispatch({\n              type: _constants.actionTypes.SESSION_END\n            });\n          });\n        }\n\n        onlineRef.set(!0), onlineRef.onDisconnect().remove();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["../../src/utils/auth.js"],"names":["capitalProviderName","firebase","provider","customAuthParameters","scopes","Array","email","password","type","token","phoneNumber","applicationVerifier","credential","credentials","credentialAuth","method","params","authProvider","createAuthProvider","tokenAuth","state","store","firebaseState","stateName","firebaseAuthState","isLoaded","isAuthReady","resolve","unsubscribe","config","authIsReady","authUid","profileRef","options","firestore","profileUpdatePromise","merge","ref","presence","sessions","amOnline","onlineRef","sessionsRef","snapShot","dispatch","actionTypes","payload","session","startedAt","user"],"mappings":"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","sourcesContent":["import { capitalize } from 'lodash'\nimport { supportedAuthProviders, actionTypes } from '../constants'\n\n/**\n * @description Get correct login method and params order based on provided credentials\n * @param {object} firebase - Internal firebase object\n * @param {string} providerName - Name of Auth Provider (i.e. google, github, facebook, twitter)\n * @param {Array|string} scopes - List of scopes to add to auth provider\n * @returns {firebase.auth.AuthCredential} provider - Auth Provider\n * @private\n */\nfunction createAuthProvider(firebase, providerName, scopes) {\n  // TODO: Verify scopes are valid before adding\n  // TODO: Validate parameter inputs\n  const capitalProviderName = `${capitalize(providerName)}AuthProvider`\n\n  // Throw if auth provider does not exist on Firebase instance\n  if (!firebase.auth[capitalProviderName]) {\n    throw new Error(\n      `${providerName} is not a valid auth provider for your firebase instance. If using react-native, use a RN specific auth library.`\n    )\n  }\n\n  const provider = new firebase.auth[capitalProviderName]()\n\n  // Custom Auth Parameters\n  // TODO: Validate parameter inputs\n  const { customAuthParameters } = firebase._.config\n  if (customAuthParameters && customAuthParameters[providerName]) {\n    provider.setCustomParameters(customAuthParameters[providerName])\n  }\n\n  // Handle providers without scopes\n  if (\n    providerName.toLowerCase() === 'twitter' ||\n    typeof provider.addScope !== 'function'\n  ) {\n    return provider\n  }\n\n  // TODO: Verify scopes are valid before adding\n  provider.addScope('email')\n\n  if (scopes) {\n    if (Array.isArray(scopes)) {\n      scopes.forEach(scope => {\n        provider.addScope(scope)\n      })\n    }\n    // Add single scope if it is a string\n    if (typeof scopes === 'string' || scopes instanceof String) {\n      provider.addScope(scopes)\n    }\n  }\n\n  return provider\n}\n\n/**\n * Get correct login method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.email - Email to login with (only needed for\n * email login)\n * @param {string} credentials.password - Password to login with (only needed\n * for email login)\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {string} credentials.token - Custom or provider token\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getLoginMethodAndParams(firebase, credentials) {\n  const {\n    email,\n    password,\n    provider,\n    type,\n    token,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth().signInAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'signInAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'signInWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    if (token) {\n      throw new Error(\n        'provider with token no longer supported, use credential parameter instead'\n      )\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'signInWithPopup', params: [authProvider] }\n    }\n    return { method: 'signInWithRedirect', params: [authProvider] }\n  }\n\n  // Token Auth\n  if (token) {\n    // Check for new sign in method (see #484 for more info)\n    const tokenAuth = firebase.auth().signInAndRetrieveDataWithCustomToken\n\n    if (tokenAuth) {\n      return { method: 'signInAndRetrieveDataWithCustomToken', params: [token] }\n    }\n\n    return { method: 'signInWithCustomToken', params: [token] }\n  }\n\n  // Phone Number Auth\n  if (phoneNumber) {\n    if (!applicationVerifier) {\n      throw new Error(\n        'Application verifier is required for phone authentication'\n      )\n    }\n    return {\n      method: 'signInWithPhoneNumber',\n      params: [phoneNumber, applicationVerifier]\n    }\n  }\n\n  // Check for new sign in method (see #484 for more info)\n  // Note: usage of signInAndRetrieveDataWithEmailAndPassword is now a fallback since it is deprecated (see #484 for more info)\n  if (!firebase.auth().signInWithEmailAndPassword) {\n    return {\n      method: 'signInAndRetrieveDataWithEmailAndPassword',\n      params: [email, password]\n    }\n  }\n\n  // Email/Password Auth\n  return { method: 'signInWithEmailAndPassword', params: [email, password] }\n}\n\n/**\n * Get correct reauthenticate method and params order based on provided\n * credentials\n * @param {object} firebase - Internal firebase object\n * @param {object} credentials - Login credentials\n * @param {string} credentials.provider - Provider name such as google, twitter\n * (only needed for 3rd party provider login)\n * @param {string} credentials.type - Popup or redirect (only needed for 3rd\n * party provider login)\n * @param {firebase.auth.AuthCredential} credentials.credential - Custom or\n * provider token\n * @param {Array|string} credentials.scopes - Scopes to add to provider\n * (i.e. email)\n * @returns {object} Method and params for calling login\n * @private\n */\nexport function getReauthenticateMethodAndParams(firebase, credentials) {\n  const {\n    provider,\n    type,\n    scopes,\n    phoneNumber,\n    applicationVerifier,\n    credential\n  } = credentials\n  // Credential Auth\n  if (credential) {\n    // Attempt to use signInAndRetrieveDataWithCredential if it exists (see #467 for more info)\n    const credentialAuth = firebase.auth()\n      .reauthenticateAndRetrieveDataWithCredential\n\n    if (credentialAuth) {\n      return {\n        method: 'reauthenticateAndRetrieveDataWithCredential',\n        params: [credential]\n      }\n    }\n    return { method: 'reauthenticateWithCredential', params: [credential] }\n  }\n\n  // Provider Auth\n  if (provider) {\n    // Verify providerName is valid\n    if (supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {\n      throw new Error(`${provider} is not a valid Auth Provider`)\n    }\n    const authProvider = createAuthProvider(firebase, provider, scopes)\n    if (type === 'popup') {\n      return { method: 'reauthenticateWithPopup', params: [authProvider] }\n    }\n    return { method: 'reauthenticateWithRedirect', params: [authProvider] }\n  }\n\n  // Phone Number Auth\n  if (!applicationVerifier) {\n    throw new Error('Application verifier is required for phone authentication')\n  }\n  return {\n    method: 'reauthenticateWithPhoneNumber',\n    params: [phoneNumber, applicationVerifier]\n  }\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the\n * react-redux-firebase reducer when using multiple combined reducers.\n * 'firebase' by default. Set this to `null` to indicate that the\n * react-redux-firebase reducer is not in a combined reducer.\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nfunction isAuthReady(store, stateName) {\n  const state = store.getState()\n  const firebaseState = stateName ? state[stateName] : state\n  const firebaseAuthState = firebaseState && firebaseState.auth\n  if (!firebaseAuthState) {\n    throw new Error(\n      `The Firebase auth state could not be found in the store under the attribute '${\n        stateName ? `${stateName}.` : ''\n      }auth'. Make sure your react-redux-firebase reducer is correctly set in the store`\n    )\n  }\n  return firebaseState.auth.isLoaded\n}\n\n/**\n * Returns a promise that completes when Firebase Auth is ready in the given\n * store using react-redux-firebase.\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {string} [stateName='firebase'] - The attribute name of the react-redux-firebase\n * reducer when using multiple combined reducers. 'firebase' by default. Set\n * this to `null` to indicate that the react-redux-firebase reducer is not in a\n * combined reducer.\n * @returns {Promise} Resolve when Firebase auth is ready in the store.\n */\nexport function authIsReady(store, stateName = 'firebase') {\n  return new Promise(resolve => {\n    if (isAuthReady(store, stateName)) {\n      resolve()\n    } else {\n      const unsubscribe = store.subscribe(() => {\n        if (isAuthReady(store, stateName)) {\n          unsubscribe()\n          resolve()\n        }\n      })\n    }\n  })\n}\n\n/**\n * Function that creates and authIsReady promise\n * @param {object} store - The Redux store on which we want to detect if\n * Firebase auth is ready.\n * @param {object} config - Config options for authIsReady\n * @param {string} config.authIsReady - Config options for authIsReady\n * @param {string} config.firebaseStateName - Config options for authIsReady\n * @returns {Promise} Resolves when Firebase auth is ready in the store.\n */\nexport function createAuthIsReady(store, config) {\n  return typeof config.authIsReady === 'function'\n    ? config.authIsReady(store, config)\n    : authIsReady(store, config.firebaseStateName)\n}\n\n/**\n * Update profile data on Firebase Real Time Database\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnRTDB(firebase, profileUpdate) {\n  const { _: { config, authUid } } = firebase\n  const profileRef = firebase.database().ref(`${config.userProfile}/${authUid}`)\n  return profileRef.update(profileUpdate).then(() => profileRef.once('value'))\n}\n\n/**\n * Update profile data on Firestore by calling set (with merge: true) on\n * the profile.\n * @param {object} firebase - internal firebase object\n * @param {object} profileUpdate - Updates to profile object\n * @param {object} options - Options object for configuring how profile\n * update occurs\n * @param {boolean} [options.useSet=true] - Use set with merge instead of\n * update. Setting to `false` uses update (can cause issue of profile document\n * does not exist).\n * @param {boolean} [options.merge=true] - Whether or not to use merge when\n * setting profile\n * @returns {Promise} Resolves with results of profile get\n */\nexport function updateProfileOnFirestore(\n  firebase,\n  profileUpdate,\n  options = {}\n) {\n  const { useSet = true, merge = true } = options\n  const { firestore, _: { config, authUid } } = firebase\n  const profileRef = firestore().doc(`${config.userProfile}/${authUid}`)\n  // Use set with merge (to prevent \"No document to update\") unless otherwise\n  // specificed through options\n  const profileUpdatePromise = useSet\n    ? profileRef.set(profileUpdate, { merge })\n    : profileRef.update(profileUpdate)\n  return profileUpdatePromise.then(() => profileRef.get())\n}\n\n/**\n * Start presence management for a specificed user uid.\n * Presence collection contains a list of users that are online currently.\n * Sessions collection contains a record of all user sessions.\n * This function is called within login functions if enablePresence: true.\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @private\n */\nexport function setupPresence(dispatch, firebase) {\n  // exit if database does not exist on firebase instance\n  if (!firebase.database || !firebase.database.ServerValue) {\n    return\n  }\n  const ref = firebase.database().ref()\n  const { config: { presence, sessions }, authUid } = firebase._\n  const amOnline = ref.child('.info/connected')\n  const onlineRef = ref\n    .child(\n      typeof presence === 'function'\n        ? presence(firebase.auth().currentUser, firebase)\n        : presence\n    )\n    .child(authUid)\n  let sessionsRef =\n    typeof sessions === 'function'\n      ? sessions(firebase.auth().currentUser, firebase)\n      : sessions\n  if (sessionsRef) {\n    sessionsRef = ref.child(sessions)\n  }\n  amOnline.on('value', snapShot => {\n    if (!snapShot.val()) return\n    // user is online\n    if (sessionsRef) {\n      // add session and set disconnect\n      dispatch({ type: actionTypes.SESSION_START, payload: authUid })\n      // add new session to sessions collection\n      const session = sessionsRef.push({\n        startedAt: firebase.database.ServerValue.TIMESTAMP,\n        user: authUid\n      })\n      // Support versions of react-native-firebase that do not have setPriority\n      // on firebase.database.ThenableReference\n      if (typeof session.setPriority === 'function') {\n        // set authUid as priority for easy sorting\n        session.setPriority(authUid)\n      }\n      session\n        .child('endedAt')\n        .onDisconnect()\n        .set(firebase.database.ServerValue.TIMESTAMP, () => {\n          dispatch({ type: actionTypes.SESSION_END })\n        })\n    }\n    // add correct session id to user\n    // remove from presence list\n    onlineRef.set(true)\n    onlineRef.onDisconnect().remove()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
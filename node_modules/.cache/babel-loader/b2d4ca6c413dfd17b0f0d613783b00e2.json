{"ast":null,"code":"var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n\n    if (prev) {\n      target.delete(prev);\n    }\n\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\n\nvar assign = Object.assign || function (target) {\n  var overrides = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) overrides[len] = arguments[len + 1];\n\n  overrides.forEach(function (override) {\n    return Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    });\n  });\n  return target;\n};\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\n\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n\nvar hasSet = typeof Set !== \"undefined\";\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n\nfunction makeIterable(next) {\n  var obj;\n  var self;\n  return self = (obj = {}, obj[Symbol.iterator] = function () {\n    return self;\n  }, obj.next = next, obj);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\n\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  if (isMap(obj)) {\n    return new Map(obj);\n  }\n\n  if (isSet(obj)) {\n    return new Set(obj);\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n\n  return cloned;\n}\n\nfunction freeze(obj, deep) {\n  if (deep === void 0) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\n\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) {\n      return;\n    }\n\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function (state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function (state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy.delete(key);\n      return false;\n    };\n  },\n  clear: function (state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      markChanged(state);\n      state.assigned = new Map();\n\n      for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n        var key = list[i];\n        state.assigned.set(key, false);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  forEach: function (state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function (state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function (state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n\n        state.copy.add(value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function (state) {\n    return function (value) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.delete(value);\n    };\n  },\n  has: function (state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function (state) {\n    return function () {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) args[len] = arguments[len];\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n      if (isUnchanged) {\n        return true;\n      }\n\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters((obj$1 = {}, obj$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  };\n}, obj$1.delete = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  };\n}, obj$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  };\n}, obj$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, obj$1.get = function (state) {\n  return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  };\n}, obj$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters((obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1$1.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  };\n}, obj$1$1.delete = function (state) {\n  return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  };\n}, obj$1$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  };\n}, obj$1$1.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) {\n        assignMap(copy, drafts);\n      } else {\n        assign(copy, drafts);\n      }\n\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) args[len] = arguments[len + 1];\n\n      return Reflect[name].apply(Reflect, [latest$2(state)].concat(args));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this; // curried invocation\n\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) args[len] = arguments[len + 1];\n\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n\n    if (result === NOTHING) {\n      return undefined;\n    }\n\n    if (result === undefined) {\n      result = base;\n    }\n\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) args[len] = arguments[len + 1];\n\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze(value, deep) {\n  if (deep === void 0) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":{"version":3,"sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"names":["NOTHING","Symbol","DRAFTABLE","const","DRAFT_STATE","value","isPlainObject","isMap","isSet","Array","proto","Object","override","prev","original","target","assign","overrides","key","ownKeys","Reflect","obj","base","clone","desc","writable","configurable","iter","thing","x","y","hasSymbol","hasMap","hasSet","self","next","isEntries","prop","iterator","latest","makeIterable","result","receiver","wrapSetValue","draft","state","isDraftable","createProxy","cloned","isDraft","each","freeze","ImmerScope","constructor","usePatches","revoke","leave","scope","markChangesRecursively","markChangesSweep","isArray","clonePotentialDraft","proxyMap","proxySet","proxyProperty","isEnumerable","parent","modified","finalizing","finalized","assigned","drafts","copy","revoked","createHiddenProperty","assertUnrevoked","peek","prepareCopy","is","markChanged","shallowCopy","descriptors","get","set","proxyMethod","mapTraps","finalizeTraps","size","has","delete","clear","forEach","cb","reciever","keys","values","entries","iterateMapValues","iterateSetValues","makeIterateSetValues","setTraps","add","builder","acc","traps","fn","trap","JSON","let","i","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","object","baseValue","descriptor","hasChanges","enumerable","proxy","Proxy","objectTraps","isUnchanged","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","getPrototypeOf","setPrototypeOf","arrayTraps","arguments","isNaN","parseInt","reflectTraps","makeReflectTraps","makeTrapsForGetters","assignSet","assignMap","getters","generatePatchesFn","patches","inversePatches","delta","start","end","path","basePath","op","replaceCount","origValue","applyPatches","patch","configDefaults","useProxies","autoFreeze","process","verifyMinified","onAssign","onDelete","onCopy","Immer","produce","defaultBase","recipe","call","patchListener","hasError","this","error","produceWithPatches","arg1","nextState","createDraft","finishDraft","setAutoFreeze","setUseProxies","processResult","baseDraft","isReplaced","finalize","generatePatches","finalizeTree","root","needPatches","finalizeProperty","Error","isDraftProp","isSetMember","rootPath","maybeFreeze","immer"],"mappings":"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","sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n    if (prev) { target.delete(prev); }\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) { return target.set(key, value); });\n  return target;\n}\nvar assign = Object.assign || (function (target) {\n  var overrides = [], len = arguments.length - 1;\n  while ( len-- > 0 ) overrides[ len ] = arguments[ len + 1 ];\n\n  overrides.forEach(function (override) { return Object.keys(override).forEach(function (key) { return target[key] = override[key]; }); });\n  return target;\n});\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  if (isMap(base)) { return new Map(base); }\n  if (isSet(base)) { return new Set(base); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) { return iter(index, entry, obj); });\n  } else {\n    ownKeys(obj).forEach(function (key) { return iter(key, obj[key], obj); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\nvar hasSet = typeof Set !== \"undefined\";\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\nfunction makeIterable(next) {\n  var obj;\n\n  var self;\n  return self = ( obj = {}, obj[Symbol.iterator] = function () { return self; }, obj.next = next, obj );\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  if (isMap(obj)) { return new Map(obj); }\n  if (isSet(obj)) { return new Set(obj); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction freeze(obj, deep) {\n  if ( deep === void 0 ) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) { each(obj, function (_, value) { return freeze(value, true); }); }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function (state) { return latest$1(state).size; },\n  has: function (state) { return function (key) { return latest$1(state).has(key); }; },\n  set: function (state) { return function (key, value) {\n    if (latest$1(state).get(key) !== value) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (key) {\n    prepareCopy(state);\n    markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return false;\n  }; },\n  clear: function (state) { return function () {\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    markChanged(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; },\n  forEach: function (state, key, reciever) { return function (cb) {\n    latest$1(state).forEach(function (value, key, map) {\n      cb(reciever.get(key), key, map);\n    });\n  }; },\n  get: function (state) { return function (key) {\n    var value = latest$1(state).get(key);\n\n    if (state.finalizing || state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value;\n    }\n\n    var draft = createProxy(value, state);\n    prepareCopy(state);\n    state.copy.set(key, draft);\n    return draft;\n  }; },\n  keys: function (state) { return function () { return latest$1(state).keys(); }; },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function (state) {\n    return latest$1(state).size;\n  },\n  add: function (state) { return function (value) {\n    if (!latest$1(state).has(value)) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; },\n  delete: function (state) { return function (value) {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.delete(value);\n  }; },\n  has: function (state) { return function (key) {\n    return latest$1(state).has(key);\n  }; },\n  clear: function (state) { return function () {\n    markChanged(state);\n\n    if (!state.copy) {\n      prepareCopy(state);\n    }\n\n    return state.copy.clear();\n  }; },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) { markChanged(state); }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n  if (base.size !== draft.size) { return true; } // IE11 supports only forEach iteration\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) { return state; }\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n      if (isUnchanged) { return true; }\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) { delete state.copy[prop]; }\n    return true;\n  },\n\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters(( obj$1 = {}, obj$1[DRAFT_STATE] = function (state) { return state; }, obj$1.size = function (state) { return latest$2(state).size; }, obj$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1.set = function (state) { return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  }; }, obj$1.delete = function (state) { return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  }; }, obj$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  }; }, obj$1.forEach = function (state, _, receiver) { return function (cb, thisArg) { return latest$2(state).forEach(function (_, key, map) {\n    var value = receiver.get(key);\n    cb.call(thisArg, value, key, map);\n  }); }; }, obj$1.get = function (state) { return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  }; }, obj$1.keys = function (state) { return function () { return latest$2(state).keys(); }; }, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1 ));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters(( obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) { return state; }, obj$1$1.size = function (state) { return latest$2(state).size; }, obj$1$1.has = function (state) { return function (key) { return latest$2(state).has(key); }; }, obj$1$1.add = function (state) { return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  }; }, obj$1$1.delete = function (state) { return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  }; }, obj$1$1.clear = function (state) { return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  }; }, obj$1$1.forEach = function (state) { return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  }; }, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1 ));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) { assignMap(copy, drafts); }else { assign(copy, drafts); }\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [], len = arguments.length - 1;\n      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return Reflect[name].apply(Reflect, [ latest$2(state) ].concat( args ));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n\n  });\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) { this$1.onDelete(state, prop); }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n"]},"metadata":{},"sourceType":"module"}